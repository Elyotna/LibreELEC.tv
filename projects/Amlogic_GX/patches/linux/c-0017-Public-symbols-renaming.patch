From 7b3ac852262eea842f58e2c2a2f55aa59a65da4d Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <maxi.jourdan@wanadoo.fr>
Date: Mon, 20 Aug 2018 09:26:47 +0200
Subject: [PATCH 17/35] Public symbols renaming

Add "am" in front of every vdec_ symbol.

Also export the public symbols as GPL.

+ some cleanups here and there..
---
 drivers/media/platform/meson/vdec/codec_h264.c    |  42 ++---
 drivers/media/platform/meson/vdec/codec_h264.h    |   2 +-
 drivers/media/platform/meson/vdec/codec_helpers.c |  33 ++--
 drivers/media/platform/meson/vdec/codec_helpers.h |   8 +-
 drivers/media/platform/meson/vdec/codec_hevc.c    | 193 ++++++++++------------
 drivers/media/platform/meson/vdec/codec_hevc.h    |   2 +-
 drivers/media/platform/meson/vdec/codec_mjpeg.c   |  22 +--
 drivers/media/platform/meson/vdec/codec_mjpeg.h   |   2 +-
 drivers/media/platform/meson/vdec/codec_mpeg12.c  |  22 +--
 drivers/media/platform/meson/vdec/codec_mpeg12.h  |   2 +-
 drivers/media/platform/meson/vdec/codec_mpeg4.c   |  24 +--
 drivers/media/platform/meson/vdec/codec_mpeg4.h   |   2 +-
 drivers/media/platform/meson/vdec/esparser.c      |  48 +++---
 drivers/media/platform/meson/vdec/esparser.h      |   6 +-
 drivers/media/platform/meson/vdec/vdec.c          | 174 +++++++++----------
 drivers/media/platform/meson/vdec/vdec.h          |  76 ++++-----
 drivers/media/platform/meson/vdec/vdec_1.c        |  32 ++--
 drivers/media/platform/meson/vdec/vdec_1.h        |   2 +-
 drivers/media/platform/meson/vdec/vdec_hevc.c     |  28 ++--
 drivers/media/platform/meson/vdec/vdec_hevc.h     |   2 +-
 drivers/media/platform/meson/vdec/vdec_platform.c |   6 +-
 drivers/media/platform/meson/vdec/vdec_platform.h |   4 +-
 22 files changed, 361 insertions(+), 371 deletions(-)

diff --git a/drivers/media/platform/meson/vdec/codec_h264.c b/drivers/media/platform/meson/vdec/codec_h264.c
index 764b33b..3b30dd4 100644
--- a/drivers/media/platform/meson/vdec/codec_h264.c
+++ b/drivers/media/platform/meson/vdec/codec_h264.c
@@ -48,13 +48,13 @@ struct codec_h264 {
 	dma_addr_t sei_paddr;
 };
 
-static int codec_h264_can_recycle(struct vdec_core *core)
+static int codec_h264_can_recycle(struct amvdec_core *core)
 {
 	return !readl_relaxed(core->dos_base + AV_SCRATCH_7) ||
 	       !readl_relaxed(core->dos_base + AV_SCRATCH_8);
 }
 
-static void codec_h264_recycle(struct vdec_core *core, u32 buf_idx)
+static void codec_h264_recycle(struct amvdec_core *core, u32 buf_idx)
 {
 	/* Tell the decoder he can recycle this buffer.
 	 * AV_SCRATCH_8 serves the same purpose.
@@ -65,9 +65,9 @@ static void codec_h264_recycle(struct vdec_core *core, u32 buf_idx)
 		writel_relaxed(buf_idx + 1, core->dos_base + AV_SCRATCH_8);
 }
 
-static int codec_h264_start(struct vdec_session *sess) {
+static int codec_h264_start(struct amvdec_session *sess) {
 	u32 workspace_offset;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct codec_h264 *h264 = sess->priv;
 
 	/* Allocate some memory for the H.264 decoder's state */
@@ -129,10 +129,10 @@ static int codec_h264_start(struct vdec_session *sess) {
 	return 0;
 }
 
-static int codec_h264_stop(struct vdec_session *sess)
+static int codec_h264_stop(struct amvdec_session *sess)
 {
 	struct codec_h264 *h264 = sess->priv;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	if (h264->ext_fw_vaddr)
 		dma_free_coherent(core->dev, SIZE_EXT_FW, h264->ext_fw_vaddr, h264->ext_fw_paddr);
@@ -149,10 +149,10 @@ static int codec_h264_stop(struct vdec_session *sess)
 	return 0;
 }
 
-static int codec_h264_load_extended_firmware(struct vdec_session *sess, const u8 *data, u32 len)
+static int codec_h264_load_extended_firmware(struct amvdec_session *sess, const u8 *data, u32 len)
 {
 	struct codec_h264 *h264;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	
 	h264 = kzalloc(sizeof(*h264), GFP_KERNEL);
 	if (!h264)
@@ -177,13 +177,13 @@ static int codec_h264_load_extended_firmware(struct vdec_session *sess, const u8
 /* Configure the H.264 decoder when the esparser finished parsing
  * the first buffer.
  */
-static void codec_h264_set_param(struct vdec_session *sess) {
+static void codec_h264_set_param(struct amvdec_session *sess) {
 	u32 max_reference_size;
 	u32 parsed_info, mb_width, mb_height, mb_total;
 	u32 mb_mv_byte;
 	u32 actual_dpb_size = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
 	u32 max_dpb_size = 4;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct codec_h264 *h264 = sess->priv;
 
 	sess->keyframe_found = 1;
@@ -213,7 +213,7 @@ static void codec_h264_set_param(struct vdec_session *sess) {
 	mb_height = (mb_height + 3) & 0xfffffffc;
 	mb_total = mb_width * mb_height;
 
-	codec_helper_set_canvases(sess, core->dos_base + ANC0_CANVAS_ADDR);
+	amcodec_helper_set_canvases(sess, core->dos_base + ANC0_CANVAS_ADDR);
 
 	if (max_reference_size > max_dpb_size)
 		max_dpb_size = max_reference_size;
@@ -227,7 +227,7 @@ static void codec_h264_set_param(struct vdec_session *sess) {
 	h264->ref_vaddr = dma_alloc_coherent(core->dev, h264->ref_size, &h264->ref_paddr, GFP_KERNEL);
 	if (!h264->ref_vaddr) {
 		dev_err(core->dev, "Failed to allocate memory for refs (%u)\n", h264->ref_size);
-		vdec_abort(sess);
+		amvdec_abort(sess);
 		return;
 	}
 
@@ -238,9 +238,9 @@ static void codec_h264_set_param(struct vdec_session *sess) {
 	writel_relaxed((max_reference_size << 24) | (actual_dpb_size << 16) | (max_dpb_size << 8), core->dos_base + AV_SCRATCH_0);
 }
 
-static void codec_h264_frames_ready(struct vdec_session *sess, u32 status)
+static void codec_h264_frames_ready(struct amvdec_session *sess, u32 status)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	int error_count;
 	int error;
 	int num_frames;
@@ -269,13 +269,13 @@ static void codec_h264_frames_ready(struct vdec_session *sess, u32 status)
 			dev_info(core->dev, "Buffer %d decode error\n",
 				 buffer_index);
 
-		vdec_dst_buf_done_idx(sess, buffer_index);
+		amvdec_dst_buf_done_idx(sess, buffer_index);
 	}
 }
 
-static irqreturn_t codec_h264_threaded_isr(struct vdec_session *sess)
+static irqreturn_t codec_h264_threaded_isr(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	u32 status;
 	u32 size;
 	u8 cmd;
@@ -317,20 +317,20 @@ static irqreturn_t codec_h264_threaded_isr(struct vdec_session *sess)
 
 	return IRQ_HANDLED;
 abort:
-	vdec_abort(sess);
+	amvdec_abort(sess);
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t codec_h264_isr(struct vdec_session *sess)
+static irqreturn_t codec_h264_isr(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	writel_relaxed(1, core->dos_base + ASSIST_MBOX1_CLR_REG);
 
 	return IRQ_WAKE_THREAD;
 }
 
-struct vdec_codec_ops codec_h264_ops = {
+struct amvdec_codec_ops codec_h264_ops = {
 	.start = codec_h264_start,
 	.stop = codec_h264_stop,
 	.load_extended_firmware = codec_h264_load_extended_firmware,
diff --git a/drivers/media/platform/meson/vdec/codec_h264.h b/drivers/media/platform/meson/vdec/codec_h264.h
index 1a15913..7a15976 100644
--- a/drivers/media/platform/meson/vdec/codec_h264.h
+++ b/drivers/media/platform/meson/vdec/codec_h264.h
@@ -8,6 +8,6 @@
 
 #include "vdec.h"
 
-extern struct vdec_codec_ops codec_h264_ops;
+extern struct amvdec_codec_ops codec_h264_ops;
 
 #endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/codec_helpers.c b/drivers/media/platform/meson/vdec/codec_helpers.c
index 5e3fed5..6296c18 100644
--- a/drivers/media/platform/meson/vdec/codec_helpers.c
+++ b/drivers/media/platform/meson/vdec/codec_helpers.c
@@ -10,33 +10,36 @@
 #include "canvas.h"
 
 /* 4 KiB per 64x32 block */
-u32 codec_am21c_body_size(u32 width, u32 height)
+u32 amcodec_am21c_body_size(u32 width, u32 height)
 {
 	u32 width_64 = ALIGN(width, 64) / 64;
 	u32 height_32 = ALIGN(height, 32) / 32;
 
 	return SZ_4K * width_64 * height_32;
 }
+EXPORT_SYMBOL_GPL(amcodec_am21c_body_size);
 
 /* 32 bytes per 128x64 block */
-u32 codec_am21c_head_size(u32 width, u32 height)
+u32 amcodec_am21c_head_size(u32 width, u32 height)
 {
 	u32 width_128 = ALIGN(width, 128) / 128;
 	u32 height_64 = ALIGN(height, 64) / 64;
 
 	return 32 * width_128 * height_64;
 }
+EXPORT_SYMBOL_GPL(amcodec_am21c_head_size);
 
-u32 codec_am21c_size(u32 width, u32 height)
+u32 amcodec_am21c_size(u32 width, u32 height)
 {
-	return ALIGN(codec_am21c_body_size(width, height) +
-		     codec_am21c_head_size(width, height), SZ_64K);
+	return ALIGN(amcodec_am21c_body_size(width, height) +
+		     amcodec_am21c_head_size(width, height), SZ_64K);
 }
+EXPORT_SYMBOL_GPL(amcodec_am21c_size);
 
-void
-codec_helper_set_canvases_yuv420m(struct vdec_session *sess, void *reg_base)
+static void
+codec_helper_set_canvas_yuv420m(struct amvdec_session *sess, void *reg_base)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	u32 width = ALIGN(sess->width, 64);
 	u32 height = ALIGN(sess->height, 64);
 	struct v4l2_m2m_buffer *buf;
@@ -77,9 +80,10 @@ codec_helper_set_canvases_yuv420m(struct vdec_session *sess, void *reg_base)
 	}
 }
 
-void codec_helper_set_canvases_nv12m(struct vdec_session *sess, void *reg_base)
+static void
+codec_helper_set_canvas_nv12m(struct amvdec_session *sess, void *reg_base)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	u32 width = ALIGN(sess->width, 64);
 	u32 height = ALIGN(sess->height, 64);
 	struct v4l2_m2m_buffer *buf;
@@ -112,18 +116,19 @@ void codec_helper_set_canvases_nv12m(struct vdec_session *sess, void *reg_base)
 	}
 }
 
-void codec_helper_set_canvases(struct vdec_session *sess, void *reg_base)
+void amcodec_helper_set_canvases(struct amvdec_session *sess, void *reg_base)
 {
 	u32 pixfmt = sess->pixfmt_cap;
 
 	switch (pixfmt) {
 	case V4L2_PIX_FMT_NV12M:
-		codec_helper_set_canvases_nv12m(sess, reg_base);
+		codec_helper_set_canvas_nv12m(sess, reg_base);
 		break;
 	case V4L2_PIX_FMT_YUV420M:
-		codec_helper_set_canvases_yuv420m(sess, reg_base);
+		codec_helper_set_canvas_yuv420m(sess, reg_base);
 		break;
 	default:
 		dev_err(sess->core->dev, "Unsupported pixfmt %08X\n", pixfmt);
 	};
-}
\ No newline at end of file
+}
+EXPORT_SYMBOL_GPL(amcodec_helper_set_canvases);
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/codec_helpers.h b/drivers/media/platform/meson/vdec/codec_helpers.h
index 96c3cc5..dd96c50 100644
--- a/drivers/media/platform/meson/vdec/codec_helpers.h
+++ b/drivers/media/platform/meson/vdec/codec_helpers.h
@@ -3,9 +3,9 @@
 
 #include "vdec.h"
 
-void codec_helper_set_canvases(struct vdec_session *sess, void *reg_base);
-u32 codec_am21c_body_size(u32 width, u32 height);
-u32 codec_am21c_head_size(u32 width, u32 height);
-u32 codec_am21c_size(u32 width, u32 height);
+void amcodec_helper_set_canvases(struct amvdec_session *sess, void *reg_base);
+u32 amcodec_am21c_body_size(u32 width, u32 height);
+u32 amcodec_am21c_head_size(u32 width, u32 height);
+u32 amcodec_am21c_size(u32 width, u32 height);
 
 #endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/codec_hevc.c b/drivers/media/platform/meson/vdec/codec_hevc.c
index 6bd03df..097ec84 100644
--- a/drivers/media/platform/meson/vdec/codec_hevc.c
+++ b/drivers/media/platform/meson/vdec/codec_hevc.c
@@ -293,7 +293,7 @@ struct codec_hevc {
 	u32 tile_height_lcu;
 };
 
-static u32 codec_hevc_num_pending_bufs(struct vdec_session *sess)
+static u32 codec_hevc_num_pending_bufs(struct amvdec_session *sess)
 {
 	struct codec_hevc *hevc;
 	u32 ret;
@@ -312,7 +312,7 @@ static u32 codec_hevc_num_pending_bufs(struct vdec_session *sess)
 }
 
 /* Update the L0 and L1 reference lists for a given frame */
-static void codec_hevc_update_frame_refs(struct vdec_session *sess, struct hevc_frame *frame)
+static void codec_hevc_update_frame_refs(struct amvdec_session *sess, struct hevc_frame *frame)
 {
 	struct codec_hevc *hevc = sess->priv;
 	union rpm_param *params = &hevc->rpm_param;
@@ -360,15 +360,15 @@ static void codec_hevc_update_frame_refs(struct vdec_session *sess, struct hevc_
 		goto end;
 
 	for (i = 0; i < num_ref_idx_l0_active; i++) {
-		int cIdx;
+		int cidx;
 		if (params->p.modification_flag & 0x1)
-			cIdx = params->p.modification_list[i];
+			cidx = params->p.modification_list[i];
 		else
-			cIdx = i % total_num;
+			cidx = i % total_num;
 
 		frame->ref_poc_list[0][frame->cur_slice_idx][i] =
-			cIdx >= num_neg ? ref_picset1[cIdx - num_neg] :
-			ref_picset0[cIdx];
+			cidx >= num_neg ? ref_picset1[cidx - num_neg] :
+			ref_picset0[cidx];
 	}
 
 	if (params->p.slice_type != B_SLICE)
@@ -376,23 +376,23 @@ static void codec_hevc_update_frame_refs(struct vdec_session *sess, struct hevc_
 
 	if (params->p.modification_flag & 0x2) {
 		for (i = 0; i < num_ref_idx_l1_active; i++) {
-			int cIdx;
+			int cidx;
 			if (params->p.modification_flag & 0x1)
-				cIdx =
+				cidx =
 				params->p.modification_list[num_ref_idx_l0_active + i];
 			else
-				cIdx = params->p.modification_list[i];
+				cidx = params->p.modification_list[i];
 
 			frame->ref_poc_list[1][frame->cur_slice_idx][i] =
-				(cIdx >= num_pos) ? ref_picset0[cIdx - num_pos]
-				: ref_picset1[cIdx];
+				(cidx >= num_pos) ? ref_picset0[cidx - num_pos]
+				: ref_picset1[cidx];
 		}
 	} else {
 		for (i = 0; i < num_ref_idx_l1_active; i++) {
-			int cIdx = i % total_num;
+			int cidx = i % total_num;
 			frame->ref_poc_list[1][frame->cur_slice_idx][i] =
-				cIdx >= num_pos ? ref_picset0[cIdx - num_pos] :
-				ref_picset1[cIdx];
+				cidx >= num_pos ? ref_picset0[cidx - num_pos] :
+				ref_picset1[cidx];
 		}
 	}
 
@@ -486,21 +486,8 @@ static struct hevc_frame *codec_hevc_get_lowest_poc_frame(struct codec_hevc *hev
 	return ret;
 }
 
-static void codec_hevc_drain(struct vdec_session *sess)
-{
-	struct hevc_frame *tmp;
-	struct codec_hevc *hevc = sess->priv;
-
-	while ((tmp = codec_hevc_get_lowest_poc_frame(hevc))) {
-		vdec_dst_buf_done(sess, tmp->vbuf);
-		list_del(&tmp->list);
-		kfree(tmp);
-		hevc->frames_num--;
-	}
-}
-
 /* Try to output as many frames as possible */
-static void codec_hevc_output_frames(struct vdec_session *sess)
+static void codec_hevc_output_frames(struct amvdec_session *sess)
 {
 	struct hevc_frame *tmp;
 	struct codec_hevc *hevc = sess->priv;
@@ -512,7 +499,7 @@ static void codec_hevc_output_frames(struct vdec_session *sess)
 
 		dev_dbg(sess->core->dev, "DONE frame poc %u; vbuf %u\n",
 			tmp->poc, tmp->vbuf->vb2_buf.index);
-		vdec_dst_buf_done(sess, tmp->vbuf);
+		amvdec_dst_buf_done(sess, tmp->vbuf);
 		list_del(&tmp->list);
 		kfree(tmp);
 		hevc->frames_num--;
@@ -520,11 +507,11 @@ static void codec_hevc_output_frames(struct vdec_session *sess)
 }
 
 /* Configure frame buffer decompression */
-static void codec_hevc_setup_decode_head(struct vdec_session *sess)
+static void codec_hevc_setup_decode_head(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
-	u32 body_size = codec_am21c_body_size(sess->width, sess->height);
-	u32 head_size = codec_am21c_head_size(sess->width, sess->height);
+	struct amvdec_core *core = sess->core;
+	u32 body_size = amcodec_am21c_body_size(sess->width, sess->height);
+	u32 head_size = amcodec_am21c_head_size(sess->width, sess->height);
 
 	writel_relaxed(0, core->dos_base + HEVCD_MPP_DECOMP_CTL1);
 	writel_relaxed(body_size / 32, core->dos_base + HEVCD_MPP_DECOMP_CTL2);
@@ -533,9 +520,9 @@ static void codec_hevc_setup_decode_head(struct vdec_session *sess)
 	writel_relaxed(head_size, core->dos_base + HEVC_CM_HEADER_LENGTH);
 }
 
-static void codec_hevc_setup_buffers_gxbb(struct vdec_session *sess)
+static void codec_hevc_setup_buffers_gxbb(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct v4l2_m2m_buffer *buf;
 	u32 buf_num = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
 	dma_addr_t buf_y_paddr = 0;
@@ -573,9 +560,9 @@ static void codec_hevc_setup_buffers_gxbb(struct vdec_session *sess)
 		writel_relaxed(0, core->dos_base + HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
 }
 
-static void codec_hevc_setup_buffers_gxl(struct vdec_session *sess)
+static void codec_hevc_setup_buffers_gxl(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct v4l2_m2m_buffer *buf;
 	u32 buf_num = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
 	dma_addr_t buf_y_paddr = 0;
@@ -606,9 +593,9 @@ static void codec_hevc_setup_buffers_gxl(struct vdec_session *sess)
 		writel_relaxed(0, core->dos_base + HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
 }
 
-static int codec_hevc_setup_workspace(struct vdec_session *sess)
+static int codec_hevc_setup_workspace(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct codec_hevc *hevc = sess->priv;
 
 	/* Allocate some memory for the HEVC decoder's state */
@@ -651,9 +638,9 @@ static int codec_hevc_setup_workspace(struct vdec_session *sess)
 	return 0;
 }
 
-static int codec_hevc_start(struct vdec_session *sess)
+static int codec_hevc_start(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct codec_hevc *hevc;
 	int ret;
 	int i;
@@ -749,23 +736,23 @@ static int codec_hevc_start(struct vdec_session *sess)
 	return ret;
 }
 
-static void codec_hevc_flush_output(struct vdec_session *sess)
+static void codec_hevc_flush_output(struct amvdec_session *sess)
 {
 	struct codec_hevc *hevc = sess->priv;
 	struct hevc_frame *tmp, *n;
 
 	list_for_each_entry_safe(tmp, n, &hevc->ref_frames_list, list) {
-		vdec_dst_buf_done(sess, tmp->vbuf);
+		amvdec_dst_buf_done(sess, tmp->vbuf);
 		list_del(&tmp->list);
 		kfree(tmp);
 		hevc->frames_num--;
 	}
 }
 
-static int codec_hevc_stop(struct vdec_session *sess)
+static int codec_hevc_stop(struct amvdec_session *sess)
 {
 	struct codec_hevc *hevc = sess->priv;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	mutex_lock(&sess->codec_lock);
 	codec_hevc_flush_output(sess);
@@ -794,10 +781,10 @@ static int codec_hevc_stop(struct vdec_session *sess)
 	return 0;
 }
 
-static void codec_hevc_update_tiles(struct vdec_session *sess)
+static void codec_hevc_update_tiles(struct amvdec_session *sess)
 {
 	struct codec_hevc *hevc = sess->priv;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	u32 sao_mem_unit = (hevc->lcu_size == 16 ? 9 : hevc->lcu_size == 32 ? 14 : 24) << 4;
 	u32 pic_height_cu = (hevc->height + hevc->lcu_size - 1) / hevc->lcu_size;
 	u32 pic_width_cu = (hevc->width + hevc->lcu_size - 1) / hevc->lcu_size;
@@ -841,7 +828,7 @@ static struct hevc_frame * codec_hevc_get_frame_by_poc(struct codec_hevc *hevc,
 	return NULL;
 }
 
-static struct hevc_frame * codec_hevc_prepare_new_frame(struct vdec_session *sess)
+static struct hevc_frame * codec_hevc_prepare_new_frame(struct amvdec_session *sess)
 {
 	struct vb2_v4l2_buffer *vbuf;
 	struct hevc_frame *new_frame = NULL;
@@ -870,9 +857,9 @@ static struct hevc_frame * codec_hevc_prepare_new_frame(struct vdec_session *ses
 	return new_frame;
 }
 
-static void codec_hevc_set_sao(struct vdec_session *sess, struct hevc_frame *frame)
+static void codec_hevc_set_sao(struct amvdec_session *sess, struct hevc_frame *frame)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct codec_hevc *hevc = sess->priv;
 	union rpm_param *param = &hevc->rpm_param;
 	dma_addr_t buf_y_paddr = vb2_dma_contig_plane_dma_addr(&frame->vbuf->vb2_buf, 0);
@@ -896,8 +883,8 @@ static void codec_hevc_set_sao(struct vdec_session *sess, struct hevc_frame *fra
 	} else if (sess->pixfmt_cap == V4L2_PIX_FMT_AM21C) {
 		writel_relaxed(buf_y_paddr, core->dos_base + HEVC_CM_BODY_START_ADDR);
 	}
-	writel_relaxed(vdec_get_output_size(sess), core->dos_base + HEVC_SAO_Y_LENGTH);
-	writel_relaxed((vdec_get_output_size(sess) / 2), core->dos_base + HEVC_SAO_C_LENGTH);
+	writel_relaxed(amvdec_get_output_size(sess), core->dos_base + HEVC_SAO_Y_LENGTH);
+	writel_relaxed((amvdec_get_output_size(sess) / 2), core->dos_base + HEVC_SAO_C_LENGTH);
 
 	if (frame->cur_slice_idx == 0) {
 		writel_relaxed(hevc->width | (hevc->height << 16), core->dos_base + HEVC_DBLK_CFG2);
@@ -996,9 +983,9 @@ static dma_addr_t codec_hevc_get_frame_mv_paddr(struct codec_hevc *hevc, struct
 }
 
 /* Update the necessary information for motion prediction with the current slice */
-static void codec_hevc_set_mpred(struct vdec_session *sess, struct hevc_frame *frame, struct hevc_frame *col_frame)
+static void codec_hevc_set_mpred(struct amvdec_session *sess, struct hevc_frame *frame, struct hevc_frame *col_frame)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct codec_hevc *hevc = sess->priv;
 	union rpm_param *param = &hevc->rpm_param;
 	u32 *ref_num = frame->ref_num;
@@ -1037,18 +1024,18 @@ static void codec_hevc_set_mpred(struct vdec_session *sess, struct hevc_frame *f
 		mv_rd_en = 0;
 
 	val = slice_type |
-			  1 << 2 | // new pic
-			  1 << 3 | // new tile
-			  is_next_slice_segment << 4 |
-			  tmvp_flag << 5 |
-			  hevc->ldc_flag << 6 |
-			  col_from_l0_flag << 7 |
-			  1 << 9 |
-			  1 << 10 |
-			  mv_rd_en << 11 |
-			  1 << 13 |
-			  lcu_size_log2 << 16 |
-			  3 << 20 | plevel << 24;
+	      1 << 2 | // new pic
+	      1 << 3 | // new tile
+	      is_next_slice_segment << 4 |
+	      tmvp_flag << 5 |
+	      hevc->ldc_flag << 6 |
+	      col_from_l0_flag << 7 |
+	      1 << 9 |
+	      1 << 10 |
+	      mv_rd_en << 11 |
+	      1 << 13 |
+	      lcu_size_log2 << 16 |
+	      3 << 20 | plevel << 24;
 	writel_relaxed(val, core->dos_base + HEVC_MPRED_CTRL0);
 
 	val = max_num_merge_cand | 2 << 4 | 3 << 8 | 5 << 12 | 36 << 16;
@@ -1087,9 +1074,9 @@ static void codec_hevc_set_mpred(struct vdec_session *sess, struct hevc_frame *f
 }
 
 /*  motion compensation reference cache controller */
-static void codec_hevc_set_mcrcc(struct vdec_session *sess)
+static void codec_hevc_set_mcrcc(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct codec_hevc *hevc = sess->priv;
 	u32 val, val_2;
 	int l0_cnt = hevc->cur_frame->ref_num[0];
@@ -1142,12 +1129,12 @@ static void codec_hevc_set_mcrcc(struct vdec_session *sess)
 	writel_relaxed(0xff0, core->dos_base + HEVCD_MCRCC_CTL1);
 }
 
-static void codec_hevc_set_ref_list(struct vdec_session *sess,
+static void codec_hevc_set_ref_list(struct amvdec_session *sess,
 				u32 ref_num, u32 *ref_poc_list)
 {
 	struct codec_hevc *hevc = sess->priv;
 	struct hevc_frame *ref_frame;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	int i;
 	u32 ref_frame_id;
 
@@ -1169,9 +1156,9 @@ static void codec_hevc_set_ref_list(struct vdec_session *sess,
 	}
 }
 
-static void codec_hevc_set_mc(struct vdec_session *sess, struct hevc_frame *frame)
+static void codec_hevc_set_mc(struct amvdec_session *sess, struct hevc_frame *frame)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	if (frame->cur_slice_type == I_SLICE)
 		return;
@@ -1217,17 +1204,17 @@ static void codec_hevc_update_col_frame(struct codec_hevc *hevc)
 		hevc->col_frame = hevc->cur_frame;
 }
 
-static void codec_hevc_update_pocs(struct vdec_session *sess)
+static void codec_hevc_update_pocs(struct amvdec_session *sess)
 {
 	struct codec_hevc *hevc = sess->priv;
 	union rpm_param *param = &hevc->rpm_param;
 	u32 nal_unit_type = param->p.m_nalUnitType;
 	u32 temporal_id = param->p.m_temporalId & 0x7;
-	int iMaxPOClsb = 1 << (param->p.log2_max_pic_order_cnt_lsb_minus4 + 4);
-	int iPrevPOClsb;
-	int iPrevPOCmsb;
-	int iPOCmsb;
-	int iPOClsb = param->p.POClsb;
+	int max_poc_lsb = 1 << (param->p.log2_max_pic_order_cnt_lsb_minus4 + 4);
+	int prev_poc_lsb;
+	int prev_poc_msb;
+	int poc_msb;
+	int poc_lsb = param->p.POClsb;
 
 	if (nal_unit_type == NAL_UNIT_CODED_SLICE_IDR ||
 	    nal_unit_type == NAL_UNIT_CODED_SLICE_IDR_N_LP) {
@@ -1238,27 +1225,27 @@ static void codec_hevc_update_pocs(struct vdec_session *sess)
 		return;
 	}
 
-	iPrevPOClsb = hevc->iPrevTid0POC % iMaxPOClsb;
-	iPrevPOCmsb = hevc->iPrevTid0POC - iPrevPOClsb;
+	prev_poc_lsb = hevc->iPrevTid0POC % max_poc_lsb;
+	prev_poc_msb = hevc->iPrevTid0POC - prev_poc_lsb;
 
-	if ((iPOClsb < iPrevPOClsb) && ((iPrevPOClsb - iPOClsb) >= (iMaxPOClsb / 2)))
-		iPOCmsb = iPrevPOCmsb + iMaxPOClsb;
-	else if ((iPOClsb > iPrevPOClsb) && ((iPOClsb - iPrevPOClsb) > (iMaxPOClsb / 2)))
-		iPOCmsb = iPrevPOCmsb - iMaxPOClsb;
+	if ((poc_lsb < prev_poc_lsb) && ((prev_poc_lsb - poc_lsb) >= (max_poc_lsb / 2)))
+		poc_msb = prev_poc_msb + max_poc_lsb;
+	else if ((poc_lsb > prev_poc_lsb) && ((poc_lsb - prev_poc_lsb) > (max_poc_lsb / 2)))
+		poc_msb = prev_poc_msb - max_poc_lsb;
 	else
-		iPOCmsb = iPrevPOCmsb;
+		poc_msb = prev_poc_msb;
 
 	if (nal_unit_type == NAL_UNIT_CODED_SLICE_BLA   ||
 	    nal_unit_type == NAL_UNIT_CODED_SLICE_BLANT ||
 	    nal_unit_type == NAL_UNIT_CODED_SLICE_BLA_N_LP)
-		iPOCmsb = 0;
+		poc_msb = 0;
 
-	hevc->curr_poc = (iPOCmsb + iPOClsb);
+	hevc->curr_poc = (poc_msb + poc_lsb);
 	if ((temporal_id - 1) == 0)
 		hevc->iPrevTid0POC = hevc->curr_poc;
 }
 
-static void codec_hevc_process_segment_header(struct vdec_session *sess)
+static void codec_hevc_process_segment_header(struct amvdec_session *sess)
 {
 	struct codec_hevc *hevc = sess->priv;
 	union rpm_param *param = &hevc->rpm_param;
@@ -1275,10 +1262,10 @@ static void codec_hevc_process_segment_header(struct vdec_session *sess)
 	codec_hevc_update_pocs(sess);
 }
 
-static int codec_hevc_process_segment(struct vdec_session *sess)
+static int codec_hevc_process_segment(struct amvdec_session *sess)
 {
 	struct codec_hevc *hevc = sess->priv;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	union rpm_param *param = &hevc->rpm_param;
 	u32 slice_segment_address = param->p.slice_segment_address;
 
@@ -1313,9 +1300,9 @@ static int codec_hevc_process_segment(struct vdec_session *sess)
 	return 0;
 }
 
-static int codec_hevc_process_rpm(struct vdec_session *sess)
+static int codec_hevc_process_rpm(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct codec_hevc *hevc = sess->priv;
 	union rpm_param *rpm_param = &hevc->rpm_param;
 	u32 lcu_x_num_div, lcu_y_num_div;
@@ -1357,7 +1344,7 @@ static int codec_hevc_process_rpm(struct vdec_session *sess)
 /* The RPM section within the workspace contains
  * many information regarding the parsed bitstream
  */
-static void codec_hevc_fetch_rpm(struct vdec_session *sess)
+static void codec_hevc_fetch_rpm(struct amvdec_session *sess)
 {
 	struct codec_hevc *hevc = sess->priv;
 	u16 *rpm_vaddr = hevc->workspace_vaddr + RPM_OFFSET;
@@ -1368,9 +1355,9 @@ static void codec_hevc_fetch_rpm(struct vdec_session *sess)
 			hevc->rpm_param.l.data[i + j] = rpm_vaddr[i + 3 - j];
 }
 
-static irqreturn_t codec_hevc_threaded_isr(struct vdec_session *sess)
+static irqreturn_t codec_hevc_threaded_isr(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct codec_hevc *hevc;
 
 	mutex_lock(&sess->codec_lock);
@@ -1381,29 +1368,29 @@ static irqreturn_t codec_hevc_threaded_isr(struct vdec_session *sess)
 	if (hevc->dec_status != HEVC_SLICE_SEGMENT_DONE) {
 		dev_err(core->dev_dec, "Unrecognized dec_status: %08X\n",
 			hevc->dec_status);
-		vdec_abort(sess);
+		amvdec_abort(sess);
 		goto unlock;
 	}
 
 	sess->keyframe_found = 1;
 	codec_hevc_fetch_rpm(sess);
 	if (codec_hevc_process_rpm(sess)) {
-		vdec_abort(sess);
+		amvdec_abort(sess);
 		goto unlock;
 	}
 
 	codec_hevc_process_segment_header(sess);
 	if (codec_hevc_process_segment(sess))
-		vdec_abort(sess);
+		amvdec_abort(sess);
 
 unlock:
 	mutex_unlock(&sess->codec_lock);
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t codec_hevc_isr(struct vdec_session *sess)
+static irqreturn_t codec_hevc_isr(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct codec_hevc *hevc = sess->priv;
 
 	hevc->dec_status = readl_relaxed(core->dos_base + HEVC_DEC_STATUS_REG);
@@ -1411,11 +1398,11 @@ static irqreturn_t codec_hevc_isr(struct vdec_session *sess)
 	return IRQ_WAKE_THREAD;
 }
 
-struct vdec_codec_ops codec_hevc_ops = {
+struct amvdec_codec_ops codec_hevc_ops = {
 	.start = codec_hevc_start,
 	.stop = codec_hevc_stop,
 	.isr = codec_hevc_isr,
 	.threaded_isr = codec_hevc_threaded_isr,
 	.num_pending_bufs = codec_hevc_num_pending_bufs,
-	.drain = codec_hevc_drain,
+	.drain = codec_hevc_flush_output,
 };
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/codec_hevc.h b/drivers/media/platform/meson/vdec/codec_hevc.h
index 1cf009b..5017e874 100644
--- a/drivers/media/platform/meson/vdec/codec_hevc.h
+++ b/drivers/media/platform/meson/vdec/codec_hevc.h
@@ -8,6 +8,6 @@
 
 #include "vdec.h"
 
-extern struct vdec_codec_ops codec_hevc_ops;
+extern struct amvdec_codec_ops codec_hevc_ops;
 
 #endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/codec_mjpeg.c b/drivers/media/platform/meson/vdec/codec_mjpeg.c
index fcbdde2..9a96b5d 100644
--- a/drivers/media/platform/meson/vdec/codec_mjpeg.c
+++ b/drivers/media/platform/meson/vdec/codec_mjpeg.c
@@ -15,12 +15,12 @@
 #define MREG_TO_AMRISC		AV_SCRATCH_8
 #define MREG_FROM_AMRISC	AV_SCRATCH_9
 
-static int codec_mjpeg_can_recycle(struct vdec_core *core)
+static int codec_mjpeg_can_recycle(struct amvdec_core *core)
 {
 	return !readl_relaxed(core->dos_base + MREG_TO_AMRISC);
 }
 
-static void codec_mjpeg_recycle(struct vdec_core *core, u32 buf_idx)
+static void codec_mjpeg_recycle(struct amvdec_core *core, u32 buf_idx)
 {
 	writel_relaxed(buf_idx + 1, core->dos_base + MREG_TO_AMRISC);
 }
@@ -38,7 +38,7 @@ static const uint32_t filt_coef[] = {
 	0x10303010
 };
 
-static void codec_mjpeg_init_scaler(struct vdec_core *core)
+static void codec_mjpeg_init_scaler(struct amvdec_core *core)
 {
 	int i;
 
@@ -84,9 +84,9 @@ static void codec_mjpeg_init_scaler(struct vdec_core *core)
 	writel_relaxed(0, core->dos_base + PSCALE_RST);
 }
 
-static int codec_mjpeg_start(struct vdec_session *sess)
+static int codec_mjpeg_start(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	writel_relaxed((1 << 7) | (1 << 6), core->dos_base + DOS_SW_RESET0);
 	writel_relaxed(0, core->dos_base + DOS_SW_RESET0);
@@ -94,7 +94,7 @@ static int codec_mjpeg_start(struct vdec_session *sess)
 	writel_relaxed(12, core->dos_base + AV_SCRATCH_0);
 	writel_relaxed(0x031a, core->dos_base + AV_SCRATCH_1);
 
-	codec_helper_set_canvases(sess, core->dos_base + AV_SCRATCH_4);
+	amcodec_helper_set_canvases(sess, core->dos_base + AV_SCRATCH_4);
 	codec_mjpeg_init_scaler(core);
 
 	writel_relaxed(0, core->dos_base + MREG_TO_AMRISC);
@@ -111,16 +111,16 @@ static int codec_mjpeg_start(struct vdec_session *sess)
 	return 0;
 }
 
-static int codec_mjpeg_stop(struct vdec_session *sess)
+static int codec_mjpeg_stop(struct amvdec_session *sess)
 {
 	return 0;
 }
 
-static irqreturn_t codec_mjpeg_isr(struct vdec_session *sess)
+static irqreturn_t codec_mjpeg_isr(struct amvdec_session *sess)
 {
 	u32 reg;
 	u32 buffer_index;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	writel_relaxed(1, core->dos_base + ASSIST_MBOX1_CLR_REG);
 
@@ -129,13 +129,13 @@ static irqreturn_t codec_mjpeg_isr(struct vdec_session *sess)
 		return IRQ_HANDLED;
 
 	buffer_index = ((reg & 0x7) - 1) & 3;
-	vdec_dst_buf_done_idx(sess, buffer_index);
+	amvdec_dst_buf_done_idx(sess, buffer_index);
 
 	writel_relaxed(0, core->dos_base + MREG_FROM_AMRISC);
 	return IRQ_HANDLED;
 }
 
-struct vdec_codec_ops codec_mjpeg_ops = {
+struct amvdec_codec_ops codec_mjpeg_ops = {
 	.start = codec_mjpeg_start,
 	.stop = codec_mjpeg_stop,
 	.isr = codec_mjpeg_isr,
diff --git a/drivers/media/platform/meson/vdec/codec_mjpeg.h b/drivers/media/platform/meson/vdec/codec_mjpeg.h
index 1164c61..cc1cf73 100644
--- a/drivers/media/platform/meson/vdec/codec_mjpeg.h
+++ b/drivers/media/platform/meson/vdec/codec_mjpeg.h
@@ -8,6 +8,6 @@
 
 #include "vdec.h"
 
-extern struct vdec_codec_ops codec_mjpeg_ops;
+extern struct amvdec_codec_ops codec_mjpeg_ops;
 
 #endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/codec_mpeg12.c b/drivers/media/platform/meson/vdec/codec_mpeg12.c
index f701531..5685895 100644
--- a/drivers/media/platform/meson/vdec/codec_mpeg12.c
+++ b/drivers/media/platform/meson/vdec/codec_mpeg12.c
@@ -33,18 +33,18 @@ struct codec_mpeg12 {
 	dma_addr_t workspace_paddr;
 };
 
-static int codec_mpeg12_can_recycle(struct vdec_core *core)
+static int codec_mpeg12_can_recycle(struct amvdec_core *core)
 {
 	return !readl_relaxed(core->dos_base + MREG_BUFFERIN);
 }
 
-static void codec_mpeg12_recycle(struct vdec_core *core, u32 buf_idx)
+static void codec_mpeg12_recycle(struct amvdec_core *core, u32 buf_idx)
 {
 	writel_relaxed(buf_idx + 1, core->dos_base + MREG_BUFFERIN);
 }
 
-static int codec_mpeg12_start(struct vdec_session *sess) {
-	struct vdec_core *core = sess->core;
+static int codec_mpeg12_start(struct amvdec_session *sess) {
+	struct amvdec_core *core = sess->core;
 	struct codec_mpeg12 *mpeg12 = sess->priv;
 	int ret;
 
@@ -68,7 +68,7 @@ static int codec_mpeg12_start(struct vdec_session *sess) {
 
 	writel_relaxed((1 << 4), core->dos_base + POWER_CTL_VLD);
 
-	codec_helper_set_canvases(sess, core->dos_base + AV_SCRATCH_0);
+	amcodec_helper_set_canvases(sess, core->dos_base + AV_SCRATCH_0);
 	writel_relaxed(mpeg12->workspace_paddr + SIZE_CCBUF, core->dos_base + MREG_CO_MV_START);
 
 	writel_relaxed(0, core->dos_base + MPEG1_2_REG);
@@ -90,10 +90,10 @@ static int codec_mpeg12_start(struct vdec_session *sess) {
 	return ret;
 }
 
-static int codec_mpeg12_stop(struct vdec_session *sess)
+static int codec_mpeg12_stop(struct amvdec_session *sess)
 {
 	struct codec_mpeg12 *mpeg12 = sess->priv;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	if (mpeg12->workspace_vaddr) {
 		dma_free_coherent(core->dev, SIZE_WORKSPACE, mpeg12->workspace_vaddr, mpeg12->workspace_paddr);
@@ -103,11 +103,11 @@ static int codec_mpeg12_stop(struct vdec_session *sess)
 	return 0;
 }
 
-static irqreturn_t codec_mpeg12_isr(struct vdec_session *sess)
+static irqreturn_t codec_mpeg12_isr(struct amvdec_session *sess)
 {
 	u32 reg;
 	u32 buffer_index;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	writel_relaxed(1, core->dos_base + ASSIST_MBOX1_CLR_REG);
 
@@ -124,14 +124,14 @@ static irqreturn_t codec_mpeg12_isr(struct vdec_session *sess)
 
 	sess->keyframe_found = 1;
 	buffer_index = ((reg & 0xf) - 1) & 7;
-	vdec_dst_buf_done_idx(sess, buffer_index);
+	amvdec_dst_buf_done_idx(sess, buffer_index);
 
 end:
 	writel_relaxed(0, core->dos_base + MREG_BUFFEROUT);
 	return IRQ_HANDLED;
 }
 
-struct vdec_codec_ops codec_mpeg12_ops = {
+struct amvdec_codec_ops codec_mpeg12_ops = {
 	.start = codec_mpeg12_start,
 	.stop = codec_mpeg12_stop,
 	.isr = codec_mpeg12_isr,
diff --git a/drivers/media/platform/meson/vdec/codec_mpeg12.h b/drivers/media/platform/meson/vdec/codec_mpeg12.h
index 7dc37ad..8911b8a 100644
--- a/drivers/media/platform/meson/vdec/codec_mpeg12.h
+++ b/drivers/media/platform/meson/vdec/codec_mpeg12.h
@@ -8,6 +8,6 @@
 
 #include "vdec.h"
 
-extern struct vdec_codec_ops codec_mpeg12_ops;
+extern struct amvdec_codec_ops codec_mpeg12_ops;
 
 #endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/codec_mpeg4.c b/drivers/media/platform/meson/vdec/codec_mpeg4.c
index bf9d26b..c3dcd06 100644
--- a/drivers/media/platform/meson/vdec/codec_mpeg4.c
+++ b/drivers/media/platform/meson/vdec/codec_mpeg4.c
@@ -33,12 +33,12 @@ struct codec_mpeg4 {
 	dma_addr_t workspace_paddr;
 };
 
-static int codec_mpeg4_can_recycle(struct vdec_core *core)
+static int codec_mpeg4_can_recycle(struct amvdec_core *core)
 {
 	return !readl_relaxed(core->dos_base + MREG_BUFFERIN);
 }
 
-static void codec_mpeg4_recycle(struct vdec_core *core, u32 buf_idx)
+static void codec_mpeg4_recycle(struct amvdec_core *core, u32 buf_idx)
 {
 	writel_relaxed(~(1 << buf_idx), core->dos_base + MREG_BUFFERIN);
 }
@@ -47,9 +47,9 @@ static void codec_mpeg4_recycle(struct vdec_core *core, u32 buf_idx)
  * handle it specifically instead of using the helper
  * AV_SCRATCH_0 - AV_SCRATCH_3  ;  AV_SCRATCH_G - AV_SCRATCH_J
  */
-void codec_mpeg4_set_canvases(struct vdec_session *sess) {
+void codec_mpeg4_set_canvases(struct amvdec_session *sess) {
 	struct v4l2_m2m_buffer *buf;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	void *current_reg = core->dos_base + AV_SCRATCH_0;
 	u32 width = ALIGN(sess->width, 64);
 	u32 height = ALIGN(sess->height, 64);
@@ -82,8 +82,8 @@ void codec_mpeg4_set_canvases(struct vdec_session *sess) {
 	}
 }
 
-static int codec_mpeg4_start(struct vdec_session *sess) {
-	struct vdec_core *core = sess->core;
+static int codec_mpeg4_start(struct amvdec_session *sess) {
+	struct amvdec_core *core = sess->core;
 	struct codec_mpeg4 *mpeg4 = sess->priv;
 	int ret;
 
@@ -124,10 +124,10 @@ static int codec_mpeg4_start(struct vdec_session *sess) {
 	return ret;
 }
 
-static int codec_mpeg4_stop(struct vdec_session *sess)
+static int codec_mpeg4_stop(struct amvdec_session *sess)
 {
 	struct codec_mpeg4 *mpeg4 = sess->priv;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	if (mpeg4->workspace_vaddr) {
 		dma_free_coherent(core->dev, SIZE_WORKSPACE, mpeg4->workspace_vaddr, mpeg4->workspace_paddr);
@@ -137,11 +137,11 @@ static int codec_mpeg4_stop(struct vdec_session *sess)
 	return 0;
 }
 
-static irqreturn_t codec_mpeg4_isr(struct vdec_session *sess)
+static irqreturn_t codec_mpeg4_isr(struct amvdec_session *sess)
 {
 	u32 reg;
 	u32 buffer_index;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	reg = readl_relaxed(core->dos_base + MREG_FATAL_ERROR);
 	if (reg == 1)
@@ -153,7 +153,7 @@ static irqreturn_t codec_mpeg4_isr(struct vdec_session *sess)
 		readl_relaxed(core->dos_base + MP4_NOT_CODED_CNT);
 		readl_relaxed(core->dos_base + MP4_VOP_TIME_INC);
 		buffer_index = reg & 0x7;
-		vdec_dst_buf_done_idx(sess, buffer_index);
+		amvdec_dst_buf_done_idx(sess, buffer_index);
 		writel_relaxed(0, core->dos_base + MREG_BUFFEROUT);
 	}
 
@@ -162,7 +162,7 @@ static irqreturn_t codec_mpeg4_isr(struct vdec_session *sess)
 	return IRQ_HANDLED;
 }
 
-struct vdec_codec_ops codec_mpeg4_ops = {
+struct amvdec_codec_ops codec_mpeg4_ops = {
 	.start = codec_mpeg4_start,
 	.stop = codec_mpeg4_stop,
 	.isr = codec_mpeg4_isr,
diff --git a/drivers/media/platform/meson/vdec/codec_mpeg4.h b/drivers/media/platform/meson/vdec/codec_mpeg4.h
index a30ceed..b91b26413 100644
--- a/drivers/media/platform/meson/vdec/codec_mpeg4.h
+++ b/drivers/media/platform/meson/vdec/codec_mpeg4.h
@@ -8,6 +8,6 @@
 
 #include "vdec.h"
 
-extern struct vdec_codec_ops codec_mpeg4_ops;
+extern struct amvdec_codec_ops codec_mpeg4_ops;
 
 #endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/esparser.c b/drivers/media/platform/meson/vdec/esparser.c
index 002c720..e995b63 100644
--- a/drivers/media/platform/meson/vdec/esparser.c
+++ b/drivers/media/platform/meson/vdec/esparser.c
@@ -102,7 +102,7 @@ static const u8 eos_tail_data[EOS_TAIL_BUF_SIZE] = {
 static irqreturn_t esparser_isr(int irq, void *dev)
 {
 	int int_status;
-	struct vdec_core *core = dev;
+	struct amvdec_core *core = dev;
 
 	int_status = readl_relaxed(core->esparser_base + PARSER_INT_STATUS);
 	writel_relaxed(int_status, core->esparser_base + PARSER_INT_STATUS);
@@ -133,7 +133,7 @@ static u32 esparser_pad_start_code(struct vb2_buffer *vb)
 		memset(vaddr, 0, pad_size);
 	}
 
-	memset(vaddr + pad_size + 4, 0, 508);
+	memset(vaddr + pad_size, 0, SEARCH_PATTERN_LEN);
 	vaddr[pad_size]     = 0x00;
 	vaddr[pad_size + 1] = 0x00;
 	vaddr[pad_size + 2] = 0x01;
@@ -143,24 +143,24 @@ static u32 esparser_pad_start_code(struct vb2_buffer *vb)
 }
 
 static int
-esparser_write_data(struct vdec_core *core, dma_addr_t addr, u32 size)
+esparser_write_data(struct amvdec_core *core, dma_addr_t addr, u32 size)
 {
 	writel_relaxed(0, core->esparser_base + PFIFO_RD_PTR);
 	writel_relaxed(0, core->esparser_base + PFIFO_WR_PTR);
 	writel_relaxed(ES_WRITE | ES_PARSER_START | ES_SEARCH | (size << ES_PACK_SIZE_BIT), core->esparser_base + PARSER_CONTROL);
 
 	writel_relaxed(addr, core->esparser_base + PARSER_FETCH_ADDR);
-	writel_relaxed((7 << FETCH_ENDIAN_BIT) | (size + 512), core->esparser_base + PARSER_FETCH_CMD);
+	writel_relaxed((7 << FETCH_ENDIAN_BIT) | (size + SEARCH_PATTERN_LEN), core->esparser_base + PARSER_FETCH_CMD);
 	search_done = 0;
 
 	return wait_event_interruptible_timeout(wq, search_done != 0, HZ/5);
 }
 
-static u32 esparser_vififo_get_free_space(struct vdec_session *sess)
+static u32 esparser_vififo_get_free_space(struct amvdec_session *sess)
 {
 	u32 vififo_usage;
-	struct vdec_ops *vdec_ops = sess->fmt_out->vdec_ops;
-	struct vdec_core *core = sess->core;
+	struct amvdec_ops *vdec_ops = sess->fmt_out->vdec_ops;
+	struct amvdec_core *core = sess->core;
 
 	vififo_usage  = vdec_ops->vififo_level(sess);
 	vififo_usage += readl_relaxed(core->esparser_base + PARSER_VIDEO_HOLE);
@@ -176,33 +176,33 @@ static u32 esparser_vififo_get_free_space(struct vdec_session *sess)
 	return sess->vififo_size - vififo_usage;
 }
 
-int esparser_queue_eos(struct vdec_session *sess)
+int esparser_queue_eos(struct amvdec_session *sess)
 {
 	struct device *dev = sess->core->dev;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	void *eos_vaddr;
 	dma_addr_t eos_paddr;
 	int ret;
 
-	eos_vaddr = dma_alloc_coherent(dev, EOS_TAIL_BUF_SIZE + 512, &eos_paddr, GFP_KERNEL);
+	eos_vaddr = dma_alloc_coherent(dev, EOS_TAIL_BUF_SIZE + SEARCH_PATTERN_LEN, &eos_paddr, GFP_KERNEL);
 	if (!eos_vaddr)
 		return -ENOMEM;
 
-	memset(eos_vaddr, 0, EOS_TAIL_BUF_SIZE + 512);
+	memset(eos_vaddr, 0, EOS_TAIL_BUF_SIZE + SEARCH_PATTERN_LEN);
 	memcpy(eos_vaddr, eos_tail_data, sizeof(eos_tail_data));
 	ret = esparser_write_data(core, eos_paddr, EOS_TAIL_BUF_SIZE);
-	dma_free_coherent(dev, EOS_TAIL_BUF_SIZE + 512,
+	dma_free_coherent(dev, EOS_TAIL_BUF_SIZE + SEARCH_PATTERN_LEN,
 			  eos_vaddr, eos_paddr);
 
 	return ret;
 }
 
-static int esparser_queue(struct vdec_session *sess, struct vb2_v4l2_buffer *vbuf)
+static int esparser_queue(struct amvdec_session *sess, struct vb2_v4l2_buffer *vbuf)
 {
 	int ret;
 	struct vb2_buffer *vb = &vbuf->vb2_buf;
-	struct vdec_core *core = sess->core;
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	struct amvdec_core *core = sess->core;
+	struct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 	u32 num_dst_bufs = 0;
 	u32 payload_size = vb2_get_plane_payload(vb, 0);
 	dma_addr_t phy = vb2_dma_contig_plane_dma_addr(vb, 0);
@@ -223,7 +223,7 @@ static int esparser_queue(struct vdec_session *sess, struct vb2_v4l2_buffer *vbu
 		return -EAGAIN;
 
 	v4l2_m2m_src_buf_remove_by_buf(sess->m2m_ctx, vbuf);
-	vdec_add_ts_reorder(sess, vb->timestamp);
+	amvdec_add_ts_reorder(sess, vb->timestamp);
 	dev_dbg(core->dev, "esparser: Queuing ts = %llu ; pld_size = %u\n",
 		vb->timestamp, payload_size);
 
@@ -240,7 +240,7 @@ static int esparser_queue(struct vdec_session *sess, struct vb2_v4l2_buffer *vbu
 		if (sess->keyframe_found)
 			atomic_inc(&sess->esparser_queued_bufs);
 		else
-			vdec_remove_ts(sess, vb->timestamp);
+			amvdec_remove_ts(sess, vb->timestamp);
 
 		vbuf->flags = 0;
 		vbuf->field = V4L2_FIELD_NONE;
@@ -249,7 +249,7 @@ static int esparser_queue(struct vdec_session *sess, struct vb2_v4l2_buffer *vbu
 	}
 
 	dev_warn(core->dev, "esparser: input parsing error\n");
-	vdec_remove_ts(sess, vb->timestamp);
+	amvdec_remove_ts(sess, vb->timestamp);
 	v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);
 	writel_relaxed(0, core->esparser_base + PARSER_FETCH_CMD);
 
@@ -259,8 +259,8 @@ static int esparser_queue(struct vdec_session *sess, struct vb2_v4l2_buffer *vbu
 void esparser_queue_all_src(struct work_struct *work)
 {
 	struct v4l2_m2m_buffer *buf, *n;
-	struct vdec_session *sess =
-		container_of(work, struct vdec_session, esparser_queue_work);
+	struct amvdec_session *sess =
+		container_of(work, struct amvdec_session, esparser_queue_work);
 
 	mutex_lock(&sess->lock);
 	v4l2_m2m_for_each_src_buf_safe(sess->m2m_ctx, buf, n) {
@@ -270,10 +270,10 @@ void esparser_queue_all_src(struct work_struct *work)
 	mutex_unlock(&sess->lock);
 }
 
-int esparser_power_up(struct vdec_session *sess)
+int esparser_power_up(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
-	struct vdec_ops *vdec_ops = sess->fmt_out->vdec_ops;
+	struct amvdec_core *core = sess->core;
+	struct amvdec_ops *vdec_ops = sess->fmt_out->vdec_ops;
 
 	reset_control_reset(core->esparser_reset);
 	writel_relaxed((10 << PS_CFG_PFIFO_EMPTY_CNT_BIT) |
@@ -308,7 +308,7 @@ int esparser_power_up(struct vdec_session *sess)
 	return 0;
 }
 
-int esparser_init(struct platform_device *pdev, struct vdec_core *core)
+int esparser_init(struct platform_device *pdev, struct amvdec_core *core)
 {
 	struct device *dev = &pdev->dev;
 	int ret;
diff --git a/drivers/media/platform/meson/vdec/esparser.h b/drivers/media/platform/meson/vdec/esparser.h
index f9c8b31..a547278 100644
--- a/drivers/media/platform/meson/vdec/esparser.h
+++ b/drivers/media/platform/meson/vdec/esparser.h
@@ -8,9 +8,9 @@
 
 #include "vdec.h"
 
-int esparser_init(struct platform_device *pdev, struct vdec_core *core);
-int esparser_power_up(struct vdec_session *sess);
-int esparser_queue_eos(struct vdec_session *sess);
+int esparser_init(struct platform_device *pdev, struct amvdec_core *core);
+int esparser_power_up(struct amvdec_session *sess);
+int esparser_queue_eos(struct amvdec_session *sess);
 void esparser_queue_all_src(struct work_struct *work);
 
 #endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/vdec.c b/drivers/media/platform/meson/vdec/vdec.c
index c91ef02..71b4363 100644
--- a/drivers/media/platform/meson/vdec/vdec.c
+++ b/drivers/media/platform/meson/vdec/vdec.c
@@ -28,35 +28,37 @@
 /* 16 MiB for parsed bitstream swap exchange */
 #define SIZE_VIFIFO (16 * SZ_1M)
 
-void vdec_abort(struct vdec_session *sess)
+void amvdec_abort(struct amvdec_session *sess)
 {
 	dev_info(sess->core->dev, "Aborting decoding session!\n");
 	vb2_queue_error(&sess->m2m_ctx->cap_q_ctx.q);
 	vb2_queue_error(&sess->m2m_ctx->out_q_ctx.q);
 }
+EXPORT_SYMBOL_GPL(amvdec_abort);
 
 static u32 get_output_size(u32 width, u32 height)
 {
 	return ALIGN(width * height, 64 * SZ_1K);
 }
 
-u32 vdec_get_output_size(struct vdec_session *sess)
+u32 amvdec_get_output_size(struct amvdec_session *sess)
 {
 	return get_output_size(sess->width, sess->height);
 }
+EXPORT_SYMBOL_GPL(amvdec_get_output_size);
 
-static int vdec_codec_needs_recycle(struct vdec_session *sess)
+static int vdec_codec_needs_recycle(struct amvdec_session *sess)
 {
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	struct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 	return codec_ops->can_recycle && codec_ops->recycle;
 }
 
 static int vdec_recycle_thread(void *data)
 {
-	struct vdec_session *sess = data;
-	struct vdec_core *core = sess->core;
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
-	struct vdec_buffer *tmp, *n;
+	struct amvdec_session *sess = data;
+	struct amvdec_core *core = sess->core;
+	struct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	struct amvdec_buffer *tmp, *n;
 
 	while (!kthread_should_stop()) {
 		mutex_lock(&sess->bufs_recycle_lock);
@@ -81,10 +83,10 @@ static int vdec_recycle_thread(void *data)
 	return 0;
 }
 
-static int vdec_poweron(struct vdec_session *sess)
+static int vdec_poweron(struct amvdec_session *sess)
 {
 	int ret;
-	struct vdec_ops *vdec_ops = sess->fmt_out->vdec_ops;
+	struct amvdec_ops *vdec_ops = sess->fmt_out->vdec_ops;
 
 	ret = clk_prepare_enable(sess->core->dos_parser_clk);
 	if (ret)
@@ -110,19 +112,19 @@ static int vdec_poweron(struct vdec_session *sess)
 	return ret;
 }
 
-static void vdec_poweroff(struct vdec_session *sess) {
-	struct vdec_ops *vdec_ops = sess->fmt_out->vdec_ops;
+static void vdec_poweroff(struct amvdec_session *sess) {
+	struct amvdec_ops *vdec_ops = sess->fmt_out->vdec_ops;
 
 	vdec_ops->stop(sess);
 	clk_disable_unprepare(sess->core->dos_clk);
 	clk_disable_unprepare(sess->core->dos_parser_clk);
 }
 
-void vdec_queue_recycle(struct vdec_session *sess, struct vb2_buffer *vb)
+static void vdec_queue_recycle(struct amvdec_session *sess, struct vb2_buffer *vb)
 {
-	struct vdec_buffer *new_buf;
+	struct amvdec_buffer *new_buf;
 
-	new_buf = kmalloc(sizeof(struct vdec_buffer), GFP_KERNEL);
+	new_buf = kmalloc(sizeof(struct amvdec_buffer), GFP_KERNEL);
 	new_buf->vb = vb;
 
 	mutex_lock(&sess->bufs_recycle_lock);
@@ -131,15 +133,15 @@ void vdec_queue_recycle(struct vdec_session *sess, struct vb2_buffer *vb)
 	mutex_unlock(&sess->bufs_recycle_lock);
 }
 
-void vdec_m2m_device_run(void *priv)
+static void vdec_m2m_device_run(void *priv)
 {
-	struct vdec_session *sess = priv;
+	struct amvdec_session *sess = priv;
 	schedule_work(&sess->esparser_queue_work);
 }
 
-void vdec_m2m_job_abort(void *priv)
+static void vdec_m2m_job_abort(void *priv)
 {
-	struct vdec_session *sess = priv;
+	struct amvdec_session *sess = priv;
 	v4l2_m2m_job_finish(sess->m2m_dev, sess->m2m_ctx);
 }
 
@@ -152,32 +154,30 @@ static int vdec_queue_setup(struct vb2_queue *q,
 		unsigned int *num_buffers, unsigned int *num_planes,
 		unsigned int sizes[], struct device *alloc_devs[])
 {
-	struct vdec_session *sess = vb2_get_drv_priv(q);
-	const struct vdec_format *fmt_out = sess->fmt_out;
+	struct amvdec_session *sess = vb2_get_drv_priv(q);
+	const struct amvdec_format *fmt_out = sess->fmt_out;
 	u32 pixfmt_cap = sess->pixfmt_cap;
 	
 	switch (q->type) {
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
-		sizes[0] = vdec_get_output_size(sess);
-		sess->num_input_bufs = *num_buffers;
+		sizes[0] = amvdec_get_output_size(sess);
 		*num_planes = 1;
 		break;
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
 		if (pixfmt_cap == V4L2_PIX_FMT_NV12M) {
-			sizes[0] = vdec_get_output_size(sess);
-			sizes[1] = vdec_get_output_size(sess) / 2;
+			sizes[0] = amvdec_get_output_size(sess);
+			sizes[1] = amvdec_get_output_size(sess) / 2;
 			*num_planes = 2;
 		} else if (pixfmt_cap == V4L2_PIX_FMT_YUV420M) {
-			sizes[0] = vdec_get_output_size(sess);
-			sizes[1] = vdec_get_output_size(sess) / 4;
-			sizes[2] = vdec_get_output_size(sess) / 4;
+			sizes[0] = amvdec_get_output_size(sess);
+			sizes[1] = amvdec_get_output_size(sess) / 4;
+			sizes[2] = amvdec_get_output_size(sess) / 4;
 			*num_planes = 3;
 		} else if (pixfmt_cap == V4L2_PIX_FMT_AM21C) {
-			sizes[0] = codec_am21c_size(sess->width, sess->height);
+			sizes[0] = amcodec_am21c_size(sess->width, sess->height);
 			*num_planes = 1;
 		}
 		*num_buffers = min(max(*num_buffers, fmt_out->min_buffers), fmt_out->max_buffers);
-		sess->num_output_bufs = *num_buffers;
 		break;
 	default:
 		return -EINVAL;
@@ -188,7 +188,7 @@ static int vdec_queue_setup(struct vb2_queue *q,
 static void vdec_vb2_buf_queue(struct vb2_buffer *vb)
 {
 	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
-	struct vdec_session *sess = vb2_get_drv_priv(vb->vb2_queue);
+	struct amvdec_session *sess = vb2_get_drv_priv(vb->vb2_queue);
 	struct v4l2_m2m_ctx *m2m_ctx = sess->m2m_ctx;
 
 	mutex_lock(&sess->lock);
@@ -208,7 +208,7 @@ static void vdec_vb2_buf_queue(struct vb2_buffer *vb)
 
 static int vdec_start_streaming(struct vb2_queue *q, unsigned int count)
 {
-	struct vdec_session *sess = vb2_get_drv_priv(q);
+	struct amvdec_session *sess = vb2_get_drv_priv(q);
 	struct vb2_v4l2_buffer *buf;
 	int ret;
 
@@ -266,9 +266,9 @@ static int vdec_start_streaming(struct vb2_queue *q, unsigned int count)
 	return ret;
 }
 
-void vdec_stop_streaming(struct vb2_queue *q)
+static void vdec_stop_streaming(struct vb2_queue *q)
 {
-	struct vdec_session *sess = vb2_get_drv_priv(q);
+	struct amvdec_session *sess = vb2_get_drv_priv(q);
 	struct vb2_v4l2_buffer *buf;
 
 	mutex_lock(&sess->lock);
@@ -318,8 +318,8 @@ vdec_querycap(struct file *file, void *fh, struct v4l2_capability *cap)
 	return 0;
 }
 
-static const struct vdec_format *
-find_format(const struct vdec_format *fmts, u32 size, u32 pixfmt)
+static const struct amvdec_format *
+find_format(const struct amvdec_format *fmts, u32 size, u32 pixfmt)
 {
 	unsigned int i;
 
@@ -332,7 +332,7 @@ find_format(const struct vdec_format *fmts, u32 size, u32 pixfmt)
 }
 
 static unsigned int
-vdec_supports_pixfmt_cap(const struct vdec_format *fmt_out, u32 pixfmt_cap)
+vdec_supports_pixfmt_cap(const struct amvdec_format *fmt_out, u32 pixfmt_cap)
 {
 	int i;
 
@@ -343,13 +343,13 @@ vdec_supports_pixfmt_cap(const struct vdec_format *fmt_out, u32 pixfmt_cap)
 	return 0;
 }
 
-static const struct vdec_format *
-vdec_try_fmt_common(struct vdec_session *sess, u32 size, struct v4l2_format *f)
+static const struct amvdec_format *
+vdec_try_fmt_common(struct amvdec_session *sess, u32 size, struct v4l2_format *f)
 {
 	struct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;
 	struct v4l2_plane_pix_format *pfmt = pixmp->plane_fmt;
-	const struct vdec_format *fmts = sess->core->platform->formats;
-	const struct vdec_format *fmt_out;
+	const struct amvdec_format *fmts = sess->core->platform->formats;
+	const struct amvdec_format *fmt_out;
 
 	memset(pfmt[0].reserved, 0, sizeof(pfmt[0].reserved));
 	memset(pixmp->reserved, 0, sizeof(pixmp->reserved));
@@ -397,7 +397,7 @@ vdec_try_fmt_common(struct vdec_session *sess, u32 size, struct v4l2_format *f)
 			pixmp->num_planes = 3;
 		} else if (pixmp->pixelformat == V4L2_PIX_FMT_AM21C) {
 			pfmt[0].sizeimage =
-				codec_am21c_size(pixmp->width, pixmp->height);
+				amcodec_am21c_size(pixmp->width, pixmp->height);
 			pfmt[0].bytesperline = 0;
 		}
 	}
@@ -417,8 +417,8 @@ vdec_try_fmt_common(struct vdec_session *sess, u32 size, struct v4l2_format *f)
 
 static int vdec_try_fmt(struct file *file, void *fh, struct v4l2_format *f)
 {
-	struct vdec_session *sess =
-		container_of(file->private_data, struct vdec_session, fh);
+	struct amvdec_session *sess =
+		container_of(file->private_data, struct amvdec_session, fh);
 
 	vdec_try_fmt_common(sess, sess->core->platform->num_formats, f);
 
@@ -427,7 +427,7 @@ static int vdec_try_fmt(struct file *file, void *fh, struct v4l2_format *f)
 
 static int vdec_g_fmt(struct file *file, void *fh, struct v4l2_format *f)
 {
-	struct vdec_session *sess = container_of(file->private_data, struct vdec_session, fh);
+	struct amvdec_session *sess = container_of(file->private_data, struct amvdec_session, fh);
 	struct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;
 
 	if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
@@ -454,10 +454,10 @@ static int vdec_g_fmt(struct file *file, void *fh, struct v4l2_format *f)
 
 static int vdec_s_fmt(struct file *file, void *fh, struct v4l2_format *f)
 {
-	struct vdec_session *sess = container_of(file->private_data, struct vdec_session, fh);
+	struct amvdec_session *sess = container_of(file->private_data, struct amvdec_session, fh);
 	struct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;
 	u32 num_formats = sess->core->platform->num_formats;
-	const struct vdec_format *fmt_out;
+	const struct amvdec_format *fmt_out;
 	struct v4l2_pix_format_mplane orig_pixmp;
 	struct v4l2_format format;
 	u32 pixfmt_out = 0, pixfmt_cap = 0;
@@ -512,10 +512,10 @@ static int vdec_s_fmt(struct file *file, void *fh, struct v4l2_format *f)
 
 static int vdec_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)
 {
-	struct vdec_session *sess =
-		container_of(file->private_data, struct vdec_session, fh);
+	struct amvdec_session *sess =
+		container_of(file->private_data, struct amvdec_session, fh);
 	const struct vdec_platform *platform = sess->core->platform;
-	const struct vdec_format *fmt_out;
+	const struct amvdec_format *fmt_out;
 
 	memset(f->reserved, 0, sizeof(f->reserved));
 
@@ -540,10 +540,10 @@ static int vdec_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)
 static int vdec_enum_framesizes(struct file *file, void *fh,
 				struct v4l2_frmsizeenum *fsize)
 {
-	struct vdec_session *sess =
-		container_of(file->private_data, struct vdec_session, fh);
-	const struct vdec_format *formats = sess->core->platform->formats;
-	const struct vdec_format *fmt;
+	struct amvdec_session *sess =
+		container_of(file->private_data, struct amvdec_session, fh);
+	const struct amvdec_format *formats = sess->core->platform->formats;
+	const struct amvdec_format *fmt;
 	u32 num_formats = sess->core->platform->num_formats;
 
 	fmt = find_format(formats, num_formats, fsize->pixel_format);
@@ -584,9 +584,9 @@ vdec_try_decoder_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *cmd)
 static int
 vdec_decoder_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *cmd)
 {
-	struct vdec_session *sess =
-		container_of(file->private_data, struct vdec_session, fh);
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	struct amvdec_session *sess =
+		container_of(file->private_data, struct amvdec_session, fh);
+	struct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 	int ret;
 
 	ret = vdec_try_decoder_cmd(file, fh, cmd);
@@ -661,7 +661,7 @@ static const struct v4l2_ioctl_ops vdec_ioctl_ops = {
 static int m2m_queue_init(void *priv, struct vb2_queue *src_vq,
 			  struct vb2_queue *dst_vq)
 {
-	struct vdec_session *sess = priv;
+	struct amvdec_session *sess = priv;
 	int ret;
 
 	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
@@ -699,10 +699,10 @@ static int m2m_queue_init(void *priv, struct vb2_queue *src_vq,
 
 static int vdec_open(struct file *file)
 {
-	struct vdec_core *core = video_drvdata(file);
+	struct amvdec_core *core = video_drvdata(file);
 	struct device *dev = core->dev;
-	const struct vdec_format *formats = core->platform->formats;
-	struct vdec_session *sess;
+	const struct amvdec_format *formats = core->platform->formats;
+	struct amvdec_session *sess;
 	int ret;
 
 	mutex_lock(&core->lock);
@@ -763,9 +763,9 @@ static int vdec_open(struct file *file)
 
 static int vdec_close(struct file *file)
 {
-	struct vdec_session *sess =
-		container_of(file->private_data, struct vdec_session, fh);
-	struct vdec_core *core = sess->core;
+	struct amvdec_session *sess =
+		container_of(file->private_data, struct amvdec_session, fh);
+	struct amvdec_core *core = sess->core;
 
 	v4l2_m2m_ctx_release(sess->m2m_ctx);
 	v4l2_m2m_release(sess->m2m_dev);
@@ -779,10 +779,10 @@ static int vdec_close(struct file *file)
 	return 0;
 }
 
-void vdec_dst_buf_done(struct vdec_session *sess, struct vb2_v4l2_buffer *vbuf)
+void amvdec_dst_buf_done(struct amvdec_session *sess, struct vb2_v4l2_buffer *vbuf)
 {
 	unsigned long flags;
-	struct vdec_timestamp *tmp;
+	struct amvdec_timestamp *tmp;
 	struct device *dev = sess->core->dev_dec;
 
 	spin_lock_irqsave(&sess->bufs_spinlock, flags);
@@ -791,14 +791,14 @@ void vdec_dst_buf_done(struct vdec_session *sess, struct vb2_v4l2_buffer *vbuf)
 			vbuf->vb2_buf.index);
 
 		v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);
-		vdec_abort(sess);
+		amvdec_abort(sess);
 		goto unlock;
 	}
 
-	tmp = list_first_entry(&sess->bufs, struct vdec_timestamp, list);
+	tmp = list_first_entry(&sess->bufs, struct amvdec_timestamp, list);
 
-	vbuf->vb2_buf.planes[0].bytesused = vdec_get_output_size(sess);
-	vbuf->vb2_buf.planes[1].bytesused = vdec_get_output_size(sess) / 2;
+	vbuf->vb2_buf.planes[0].bytesused = amvdec_get_output_size(sess);
+	vbuf->vb2_buf.planes[1].bytesused = amvdec_get_output_size(sess) / 2;
 	vbuf->vb2_buf.timestamp = tmp->ts;
 	vbuf->sequence = sess->sequence_cap++;
 
@@ -821,11 +821,12 @@ void vdec_dst_buf_done(struct vdec_session *sess, struct vb2_v4l2_buffer *vbuf)
 	/* Buffer done probably means the vififo got freed */
 	schedule_work(&sess->esparser_queue_work);
 }
+EXPORT_SYMBOL_GPL(amvdec_dst_buf_done);
 
-static void vdec_rm_first_ts(struct vdec_session *sess)
+static void vdec_rm_first_ts(struct amvdec_session *sess)
 {
 	unsigned long flags;
-	struct vdec_buffer *tmp;
+	struct amvdec_buffer *tmp;
 	struct device *dev = sess->core->dev_dec;
 
 	spin_lock_irqsave(&sess->bufs_spinlock, flags);
@@ -834,7 +835,7 @@ static void vdec_rm_first_ts(struct vdec_session *sess)
 		goto unlock;
 	}
 
-	tmp = list_first_entry(&sess->bufs, struct vdec_buffer, list);
+	tmp = list_first_entry(&sess->bufs, struct amvdec_buffer, list);
 	list_del(&tmp->list);
 	kfree(tmp);
 
@@ -842,7 +843,7 @@ static void vdec_rm_first_ts(struct vdec_session *sess)
 	spin_unlock_irqrestore(&sess->bufs_spinlock, flags);
 }
 
-void vdec_dst_buf_done_idx(struct vdec_session *sess, u32 buf_idx)
+void amvdec_dst_buf_done_idx(struct amvdec_session *sess, u32 buf_idx)
 {
 	struct vb2_v4l2_buffer *vbuf;
 	struct device *dev = sess->core->dev_dec;
@@ -856,15 +857,16 @@ void vdec_dst_buf_done_idx(struct vdec_session *sess, u32 buf_idx)
 		return;
 	}
 
-	vdec_dst_buf_done(sess, vbuf);
+	amvdec_dst_buf_done(sess, vbuf);
 }
+EXPORT_SYMBOL_GPL(amvdec_dst_buf_done_idx);
 
 /* Userspace will queue src buffer timestamps that are not
  * in chronological order. Rearrange them here.
  */
-void vdec_add_ts_reorder(struct vdec_session *sess, u64 ts)
+void amvdec_add_ts_reorder(struct amvdec_session *sess, u64 ts)
 {
-	struct vdec_timestamp *new_ts, *tmp;
+	struct amvdec_timestamp *new_ts, *tmp;
 	unsigned long flags;
 
 	new_ts = kmalloc(sizeof(*new_ts), GFP_KERNEL);
@@ -887,10 +889,11 @@ void vdec_add_ts_reorder(struct vdec_session *sess, u64 ts)
 unlock:
 	spin_unlock_irqrestore(&sess->bufs_spinlock, flags);
 }
+EXPORT_SYMBOL_GPL(amvdec_add_ts_reorder);
 
-void vdec_remove_ts(struct vdec_session *sess, u64 ts)
+void amvdec_remove_ts(struct amvdec_session *sess, u64 ts)
 {
-	struct vdec_timestamp *tmp;
+	struct amvdec_timestamp *tmp;
 	unsigned long flags;
 
 	spin_lock_irqsave(&sess->bufs_spinlock, flags);
@@ -907,6 +910,7 @@ void vdec_remove_ts(struct vdec_session *sess, u64 ts)
 unlock:
 	spin_unlock_irqrestore(&sess->bufs_spinlock, flags);
 }
+EXPORT_SYMBOL_GPL(amvdec_remove_ts);
 
 static const struct v4l2_file_operations vdec_fops = {
 	.owner = THIS_MODULE,
@@ -922,8 +926,8 @@ static const struct v4l2_file_operations vdec_fops = {
 
 static irqreturn_t vdec_isr(int irq, void *data)
 {
-	struct vdec_core *core = data;
-	struct vdec_session *sess = core->cur_sess;
+	struct amvdec_core *core = data;
+	struct amvdec_session *sess = core->cur_sess;
 
 	sess->last_irq_jiffies = get_jiffies_64();
 
@@ -932,8 +936,8 @@ static irqreturn_t vdec_isr(int irq, void *data)
 
 static irqreturn_t vdec_threaded_isr(int irq, void *data)
 {
-	struct vdec_core *core = data;
-	struct vdec_session *sess = core->cur_sess;
+	struct amvdec_core *core = data;
+	struct amvdec_session *sess = core->cur_sess;
 
 	return sess->fmt_out->codec_ops->threaded_isr(sess);
 }
@@ -953,7 +957,7 @@ static int vdec_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct video_device *vdev;
-	struct vdec_core *core;
+	struct amvdec_core *core;
 	struct resource *r;
 	const struct of_device_id *of_id;
 	int irq;
@@ -1068,7 +1072,7 @@ static int vdec_probe(struct platform_device *pdev)
 
 static int vdec_remove(struct platform_device *pdev)
 {
-	struct vdec_core *core = platform_get_drvdata(pdev);
+	struct amvdec_core *core = platform_get_drvdata(pdev);
 
 	video_unregister_device(core->vdev_dec);
 
diff --git a/drivers/media/platform/meson/vdec/vdec.h b/drivers/media/platform/meson/vdec/vdec.h
index a0a237b..9b0c41e 100644
--- a/drivers/media/platform/meson/vdec/vdec.h
+++ b/drivers/media/platform/meson/vdec/vdec.h
@@ -14,26 +14,24 @@
 
 #include "vdec_platform.h"
 
-#define REG_BUF_SIZE 21
-
 struct dummy_buf {
 	struct vb2_v4l2_buffer vb;
 	struct list_head list;
 };
 
-struct vdec_buffer {
+struct amvdec_buffer {
 	struct list_head list;
 	struct vb2_buffer *vb;
 };
 
-struct vdec_timestamp {
+struct amvdec_timestamp {
 	struct list_head list;
 	u64 ts;
 };
 
-struct vdec_session;
+struct amvdec_session;
 
-struct vdec_core {
+struct amvdec_core {
 	void __iomem *dos_base;
 	void __iomem *esparser_base;
 	void __iomem *dmc_base;
@@ -53,49 +51,49 @@ struct vdec_core {
 	struct video_device *vdev_dec;
 	struct v4l2_device v4l2_dev;
 	
-	struct vdec_session *cur_sess;
+	struct amvdec_session *cur_sess;
 	struct mutex lock;
 };
 
 /* Describes one of the VDECS (VDEC_1, VDEC_2, VDEC_HCODEC, VDEC_HEVC) */
-struct vdec_ops {
-	int (*start)(struct vdec_session *sess);
-	int (*stop)(struct vdec_session *sess);
-	void (*conf_esparser)(struct vdec_session *sess);
-	u32 (*vififo_level)(struct vdec_session *sess);
+struct amvdec_ops {
+	int (*start)(struct amvdec_session *sess);
+	int (*stop)(struct amvdec_session *sess);
+	void (*conf_esparser)(struct amvdec_session *sess);
+	u32 (*vififo_level)(struct amvdec_session *sess);
 };
 
 /* Describes one of the compression standard supported (H.264, HEVC..) */
-struct vdec_codec_ops {
-	int (*start)(struct vdec_session *sess);
-	int (*stop)(struct vdec_session *sess);
-	int (*load_extended_firmware)(struct vdec_session *sess, const u8 *data, u32 len);
-	u32 (*num_pending_bufs)(struct vdec_session *sess);
-	int (*can_recycle)(struct vdec_core *core);
-	void (*recycle)(struct vdec_core *core, u32 buf_idx);
-	void (*notify_dst_buffer)(struct vdec_session *sess, struct vb2_buffer *vb);
-	void (*drain)(struct vdec_session *sess);
-	irqreturn_t (*isr)(struct vdec_session *sess);
-	irqreturn_t (*threaded_isr)(struct vdec_session *sess);
+struct amvdec_codec_ops {
+	int (*start)(struct amvdec_session *sess);
+	int (*stop)(struct amvdec_session *sess);
+	int (*load_extended_firmware)(struct amvdec_session *sess, const u8 *data, u32 len);
+	u32 (*num_pending_bufs)(struct amvdec_session *sess);
+	int (*can_recycle)(struct amvdec_core *core);
+	void (*recycle)(struct amvdec_core *core, u32 buf_idx);
+	void (*notify_dst_buffer)(struct amvdec_session *sess, struct vb2_buffer *vb);
+	void (*drain)(struct amvdec_session *sess);
+	irqreturn_t (*isr)(struct amvdec_session *sess);
+	irqreturn_t (*threaded_isr)(struct amvdec_session *sess);
 };
 
 /* Describes one of the OUTPUT format that can be decoded */
-struct vdec_format {
+struct amvdec_format {
 	u32 pixfmt;
 	u32 min_buffers;
 	u32 max_buffers;
 	u32 max_width;
 	u32 max_height;
 
-	struct vdec_ops *vdec_ops;
-	struct vdec_codec_ops *codec_ops;
+	struct amvdec_ops *vdec_ops;
+	struct amvdec_codec_ops *codec_ops;
 
 	char *firmware_path;
 	u32 pixfmts_cap[4];
 };
 
-struct vdec_session {
-	struct vdec_core *core;
+struct amvdec_session {
+	struct amvdec_core *core;
 	
 	struct v4l2_fh fh;
 	struct v4l2_m2m_dev *m2m_dev;
@@ -103,7 +101,7 @@ struct vdec_session {
 	struct mutex lock;
 	struct mutex codec_lock;
 	
-	const struct vdec_format *fmt_out;
+	const struct amvdec_format *fmt_out;
 	u32 pixfmt_cap;
 
 	u32 width;
@@ -113,9 +111,6 @@ struct vdec_session {
 	u8 quantization;
 	u8 xfer_func;
 
-	u32 num_input_bufs;
-	u32 num_output_bufs;
-
 	/* Number of buffers currently queued into ESPARSER */
 	atomic_t esparser_queued_bufs;
 
@@ -133,7 +128,7 @@ struct vdec_session {
 	 */
 	unsigned int should_stop;
 
-	/* Is set to 1 once the first keyframe has been parsed/decodeed */
+	/* Is set to 1 once the first keyframe has been parsed */
 	unsigned int keyframe_found;
 
 	/* Big contiguous area for the VIFIFO */
@@ -148,7 +143,7 @@ struct vdec_session {
 	/* Thread for recycling buffers into the hardware */
 	struct task_struct *recycle_thread;
 	
-	/* Buffers queued into the HW */
+	/* src buffers' timestamps */
 	struct list_head bufs;
 	spinlock_t bufs_spinlock;
 
@@ -159,12 +154,11 @@ struct vdec_session {
 	void *priv;
 };
 
-u32 vdec_get_output_size(struct vdec_session *sess);
-void vdec_dst_buf_done_idx(struct vdec_session *sess, u32 buf_idx);
-void vdec_dst_buf_done(struct vdec_session *sess, struct vb2_v4l2_buffer *vbuf);
-void vdec_add_ts_reorder(struct vdec_session *sess, u64 ts);
-void vdec_remove_ts(struct vdec_session *sess, u64 ts);
-void vdec_queue_recycle(struct vdec_session *sess, struct vb2_buffer *vb);
-void vdec_abort(struct vdec_session *sess);
+u32 amvdec_get_output_size(struct amvdec_session *sess);
+void amvdec_dst_buf_done_idx(struct amvdec_session *sess, u32 buf_idx);
+void amvdec_dst_buf_done(struct amvdec_session *sess, struct vb2_v4l2_buffer *vbuf);
+void amvdec_add_ts_reorder(struct amvdec_session *sess, u64 ts);
+void amvdec_remove_ts(struct amvdec_session *sess, u64 ts);
+void amvdec_abort(struct amvdec_session *sess);
 
 #endif
diff --git a/drivers/media/platform/meson/vdec/vdec_1.c b/drivers/media/platform/meson/vdec/vdec_1.c
index 78c0dd1..e50465e 100644
--- a/drivers/media/platform/meson/vdec/vdec_1.c
+++ b/drivers/media/platform/meson/vdec/vdec_1.c
@@ -33,12 +33,12 @@
 
 #define MC_SIZE			(4096 * 4)
 
-static int vdec_1_load_firmware(struct vdec_session *sess, const char* fwname)
+static int vdec_1_load_firmware(struct amvdec_session *sess, const char* fwname)
 {
 	const struct firmware *fw;
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct device *dev = core->dev_dec;
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	struct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 	static void *mc_addr;
 	static dma_addr_t mc_addr_map;
 	int ret;
@@ -91,8 +91,8 @@ static int vdec_1_load_firmware(struct vdec_session *sess, const char* fwname)
 	return ret;
 }
 
-int vdec_1_stbuf_power_up(struct vdec_session *sess) {
-	struct vdec_core *core = sess->core;
+int vdec_1_stbuf_power_up(struct amvdec_session *sess) {
+	struct amvdec_core *core = sess->core;
 
 	writel_relaxed(0, core->dos_base + VLD_MEM_VIFIFO_CONTROL);
 	writel_relaxed(0, core->dos_base + VLD_MEM_VIFIFO_WRAP_COUNT);
@@ -116,9 +116,9 @@ int vdec_1_stbuf_power_up(struct vdec_session *sess) {
 	return 0;
 }
 
-static void vdec_1_conf_esparser(struct vdec_session *sess)
+static void vdec_1_conf_esparser(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	/* VDEC_1 specific ESPARSER stuff */
 	writel_relaxed(0, core->dos_base + DOS_GEN_CTRL0); // set vififo_vbuf_rp_sel=>vdec
@@ -126,18 +126,18 @@ static void vdec_1_conf_esparser(struct vdec_session *sess)
 	writel_relaxed(readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL) & ~1, core->dos_base + VLD_MEM_VIFIFO_BUF_CNTL);
 }
 
-static u32 vdec_1_vififo_level(struct vdec_session *sess)
+static u32 vdec_1_vififo_level(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	return readl_relaxed(core->dos_base + VLD_MEM_VIFIFO_LEVEL);
 }
 
-static int vdec_1_start(struct vdec_session *sess)
+static int vdec_1_start(struct amvdec_session *sess)
 {
 	int ret;
-	struct vdec_core *core = sess->core;
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	struct amvdec_core *core = sess->core;
+	struct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 
 	clk_set_rate(core->vdec_1_clk, 666666666);
 	ret = clk_prepare_enable(core->vdec_1_clk);
@@ -188,10 +188,10 @@ static int vdec_1_start(struct vdec_session *sess)
 	return 0;
 }
 
-static int vdec_1_stop(struct vdec_session *sess)
+static int vdec_1_stop(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	struct amvdec_core *core = sess->core;
+	struct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 
 	writel_relaxed(0, core->dos_base + MPSR);
 	writel_relaxed(0, core->dos_base + CPSR);
@@ -232,7 +232,7 @@ static int vdec_1_stop(struct vdec_session *sess)
 	return 0;
 }
 
-struct vdec_ops vdec_1_ops = {
+struct amvdec_ops vdec_1_ops = {
 	.start = vdec_1_start,
 	.stop = vdec_1_stop,
 	.conf_esparser = vdec_1_conf_esparser,
diff --git a/drivers/media/platform/meson/vdec/vdec_1.h b/drivers/media/platform/meson/vdec/vdec_1.h
index b6c8b41..e20dd44 100644
--- a/drivers/media/platform/meson/vdec/vdec_1.h
+++ b/drivers/media/platform/meson/vdec/vdec_1.h
@@ -8,6 +8,6 @@
 
 #include "vdec.h"
 
-extern struct vdec_ops vdec_1_ops;
+extern struct amvdec_ops vdec_1_ops;
 
 #endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/vdec_hevc.c b/drivers/media/platform/meson/vdec/vdec_hevc.c
index 95dc3be..949f27c 100644
--- a/drivers/media/platform/meson/vdec/vdec_hevc.c
+++ b/drivers/media/platform/meson/vdec/vdec_hevc.c
@@ -17,9 +17,9 @@
 
 #define MC_SIZE	(4096 * 4)
 
-static int vdec_hevc_load_firmware(struct vdec_session *sess, const char* fwname)
+static int vdec_hevc_load_firmware(struct amvdec_session *sess, const char* fwname)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 	struct device *dev = core->dev_dec;
 	const struct firmware *fw;
 	static void *mc_addr;
@@ -69,9 +69,9 @@ static int vdec_hevc_load_firmware(struct vdec_session *sess, const char* fwname
 	return ret;
 }
 
-static void vdec_hevc_stbuf_init(struct vdec_session *sess)
+static void vdec_hevc_stbuf_init(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	writel_relaxed(readl_relaxed(core->dos_base + HEVC_STREAM_CONTROL) & ~1, core->dos_base + HEVC_STREAM_CONTROL);
 	writel_relaxed(sess->vififo_paddr, core->dos_base + HEVC_STREAM_START_ADDR);
@@ -81,9 +81,9 @@ static void vdec_hevc_stbuf_init(struct vdec_session *sess)
 }
 
 /* VDEC_HEVC specific ESPARSER configuration */
-static void vdec_hevc_conf_esparser(struct vdec_session *sess)
+static void vdec_hevc_conf_esparser(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
+	struct amvdec_core *core = sess->core;
 
 	/* set vififo_vbuf_rp_sel=>vdec_hevc */
 	writel_relaxed(3 << 1, core->dos_base + DOS_GEN_CTRL0);
@@ -92,15 +92,15 @@ static void vdec_hevc_conf_esparser(struct vdec_session *sess)
 	writel_relaxed(readl_relaxed(core->dos_base + HEVC_STREAM_FIFO_CTL) | (1 << 29), core->dos_base + HEVC_STREAM_FIFO_CTL);
 }
 
-static u32 vdec_hevc_vififo_level(struct vdec_session *sess)
+static u32 vdec_hevc_vififo_level(struct amvdec_session *sess)
 {
 	return readl_relaxed(sess->core->dos_base + HEVC_STREAM_LEVEL);
 }
 
-static int vdec_hevc_stop(struct vdec_session *sess)
+static int vdec_hevc_stop(struct amvdec_session *sess)
 {
-	struct vdec_core *core = sess->core;
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	struct amvdec_core *core = sess->core;
+	struct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 
 	/* Disable interrupt */
 	writel_relaxed(0, core->dos_base + HEVC_ASSIST_MBOX1_MASK);
@@ -123,11 +123,11 @@ static int vdec_hevc_stop(struct vdec_session *sess)
 	return 0;
 }
 
-static int vdec_hevc_start(struct vdec_session *sess)
+static int vdec_hevc_start(struct amvdec_session *sess)
 {
 	int ret;
-	struct vdec_core *core = sess->core;
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	struct amvdec_core *core = sess->core;
+	struct amvdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 
 	clk_set_rate(core->vdec_hevc_clk, 666666666);
 	ret = clk_prepare_enable(core->vdec_hevc_clk);
@@ -172,7 +172,7 @@ static int vdec_hevc_start(struct vdec_session *sess)
 	return 0;
 }
 
-struct vdec_ops vdec_hevc_ops = {
+struct amvdec_ops vdec_hevc_ops = {
 	.start = vdec_hevc_start,
 	.stop = vdec_hevc_stop,
 	.conf_esparser = vdec_hevc_conf_esparser,
diff --git a/drivers/media/platform/meson/vdec/vdec_hevc.h b/drivers/media/platform/meson/vdec/vdec_hevc.h
index a90529c..f1ccad7 100644
--- a/drivers/media/platform/meson/vdec/vdec_hevc.h
+++ b/drivers/media/platform/meson/vdec/vdec_hevc.h
@@ -17,6 +17,6 @@
 
 #include "vdec.h"
 
-extern struct vdec_ops vdec_hevc_ops;
+extern struct amvdec_ops vdec_hevc_ops;
 
 #endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/vdec_platform.c b/drivers/media/platform/meson/vdec/vdec_platform.c
index 91277e0..0c7755f 100644
--- a/drivers/media/platform/meson/vdec/vdec_platform.c
+++ b/drivers/media/platform/meson/vdec/vdec_platform.c
@@ -14,7 +14,7 @@
 #include "codec_h264.h"
 #include "codec_hevc.h"
 
-static const struct vdec_format vdec_formats_gxbb[] = {
+static const struct amvdec_format vdec_formats_gxbb[] = {
 	{
 		.pixfmt = V4L2_PIX_FMT_H264,
 		.min_buffers = 16,
@@ -98,7 +98,7 @@ static const struct vdec_format vdec_formats_gxbb[] = {
 	},
 };
 
-static const struct vdec_format vdec_formats_gxl[] = {
+static const struct amvdec_format vdec_formats_gxl[] = {
 	{
 		.pixfmt = V4L2_PIX_FMT_H264,
 		.min_buffers = 16,
@@ -182,7 +182,7 @@ static const struct vdec_format vdec_formats_gxl[] = {
 	},
 };
 
-static const struct vdec_format vdec_formats_gxm[] = {
+static const struct amvdec_format vdec_formats_gxm[] = {
 	{
 		.pixfmt = V4L2_PIX_FMT_H264,
 		.min_buffers = 16,
diff --git a/drivers/media/platform/meson/vdec/vdec_platform.h b/drivers/media/platform/meson/vdec/vdec_platform.h
index d19fad3..65c2c2a 100644
--- a/drivers/media/platform/meson/vdec/vdec_platform.h
+++ b/drivers/media/platform/meson/vdec/vdec_platform.h
@@ -8,7 +8,7 @@
 
 #include "vdec.h"
 
-struct vdec_format;
+struct amvdec_format;
 
 enum vdec_revision {
 	VDEC_REVISION_GXBB,
@@ -17,7 +17,7 @@ enum vdec_revision {
 };
 
 struct vdec_platform {
-	const struct vdec_format *formats;
+	const struct amvdec_format *formats;
 	const u32 num_formats;
 	enum vdec_revision revision;
 };
-- 
2.7.4

