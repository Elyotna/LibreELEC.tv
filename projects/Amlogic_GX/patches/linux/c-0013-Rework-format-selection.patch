From c12fc38f717f96c335d87036d3fb89ff6d5a6212 Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <maxi.jourdan@wanadoo.fr>
Date: Thu, 16 Aug 2018 16:49:28 +0200
Subject: [PATCH 13/30] Rework format selection

To comply with https://lkml.org/lkml/2018/7/24/539 :
enum_fmt only returns the CAPTURE pixfmt supported by the selected
OUTPUT fmt.
This implies that userspace should always s_fmt the OUTPUT format
before querying the available CAPTURE formats.

Also set per-codec max width and max height, and use those values
in enum_framesize/try_fmt/get_fmt/set_fmt.
---
 drivers/media/platform/meson/vdec/codec_helpers.c |   2 +-
 drivers/media/platform/meson/vdec/codec_hevc.c    |  18 +--
 drivers/media/platform/meson/vdec/vdec.c          | 169 ++++++++++------------
 drivers/media/platform/meson/vdec/vdec.h          |  10 +-
 drivers/media/platform/meson/vdec/vdec_1.c        |   2 +-
 drivers/media/platform/meson/vdec/vdec_platform.c | 144 +++++++++---------
 6 files changed, 162 insertions(+), 183 deletions(-)

diff --git a/drivers/media/platform/meson/vdec/codec_helpers.c b/drivers/media/platform/meson/vdec/codec_helpers.c
index eccfc34..0ba355e 100644
--- a/drivers/media/platform/meson/vdec/codec_helpers.c
+++ b/drivers/media/platform/meson/vdec/codec_helpers.c
@@ -90,7 +90,7 @@ void codec_helper_set_canvases_nv12m(struct vdec_session *sess, void *reg_base)
 
 void codec_helper_set_canvases(struct vdec_session *sess, void *reg_base)
 {
-	u32 pixfmt = sess->fmt_cap->pixfmt;
+	u32 pixfmt = sess->pixfmt_cap;
 
 	switch (pixfmt) {
 	case V4L2_PIX_FMT_NV12M:
diff --git a/drivers/media/platform/meson/vdec/codec_hevc.c b/drivers/media/platform/meson/vdec/codec_hevc.c
index 391c596..e7e4fb7 100644
--- a/drivers/media/platform/meson/vdec/codec_hevc.c
+++ b/drivers/media/platform/meson/vdec/codec_hevc.c
@@ -573,10 +573,8 @@ static void codec_hevc_setup_buffers_gxl(struct vdec_session *sess)
 	}
 
 	/* Fill the remaining unused slots with the last buffer's Y addr */
-	for (i = buf_size; i < MAX_REF_PIC_NUM; ++i) {
+	for (i = buf_size; i < MAX_REF_PIC_NUM; ++i)
 		writel_relaxed(buf_y_paddr  >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
-		//writel_relaxed(buf_uv_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
-	}
 
 	writel_relaxed(1, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR);
 	writel_relaxed(1, core->dos_base + HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR);
@@ -642,6 +640,7 @@ static int codec_hevc_start(struct vdec_session *sess)
 
 	INIT_LIST_HEAD(&hevc->ref_frames_list);
 	hevc->curr_poc = INVALID_POC;
+	sess->priv = hevc;
 
 	ret = codec_hevc_setup_workspace(sess);
 	if (ret)
@@ -681,7 +680,7 @@ static int codec_hevc_start(struct vdec_session *sess)
 	writel_relaxed((1 << 1), core->dos_base + HEVCD_IPP_TOP_CNTL);
 
 	/* Enable 2-plane reference read mode for MC */
-	if (sess->fmt_cap->pixfmt == V4L2_PIX_FMT_NV12M)
+	if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M)
 		writel_relaxed(1 << 31, core->dos_base + HEVCD_MPP_DECOMP_CTL1);
 
 	writel_relaxed(1, core->dos_base + HEVC_WAIT_FLAG);
@@ -715,15 +714,14 @@ static int codec_hevc_start(struct vdec_session *sess)
 	else
 		codec_hevc_setup_buffers_gxl(sess);
 
-	if (sess->fmt_cap->pixfmt != V4L2_PIX_FMT_NV12M)
+	if (sess->pixfmt_cap != V4L2_PIX_FMT_NV12M)
 		codec_hevc_setup_decode_head(sess);
 
-	sess->priv = hevc;
-
 	return 0;
 
 free_hevc:
 	kfree(hevc);
+	sess->priv = NULL;
 	return ret;
 }
 
@@ -887,7 +885,7 @@ static void codec_hevc_set_sao(struct vdec_session *sess, struct hevc_frame *fra
 	}
 
 	val = readl_relaxed(core->dos_base + HEVC_SAO_CTRL1) & ~0x3ff3;
-	if (sess->fmt_cap->pixfmt == V4L2_PIX_FMT_NV12M)
+	if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M)
 		val |= 0xff0 | /* Set endianness for 2-bytes swaps (nv12) */
 			0x1;   /* disable cm compression */
 	else
@@ -903,7 +901,7 @@ static void codec_hevc_set_sao(struct vdec_session *sess, struct hevc_frame *fra
 
 	val = readl_relaxed(core->dos_base + HEVCD_IPP_AXIIF_CONFIG) & ~0x30;
 	val |= 0xf;
-	if (sess->fmt_cap->pixfmt != V4L2_PIX_FMT_NV12M)
+	if (sess->pixfmt_cap != V4L2_PIX_FMT_NV12M)
 		val |= 0x30; /* 64x32 block mode */
 
 	writel_relaxed(val, core->dos_base + HEVCD_IPP_AXIIF_CONFIG);
@@ -1293,7 +1291,7 @@ static int codec_hevc_process_rpm(struct vdec_session *sess)
 	u32 lcu_x_num_div, lcu_y_num_div;
 
 	if (rpm_param->p.bit_depth &&
-	    sess->fmt_cap->pixfmt == V4L2_PIX_FMT_NV12M) {
+	    sess->pixfmt_cap == V4L2_PIX_FMT_NV12M) {
 		dev_err(sess->core->dev_dec,
 		    "V4L2_PIX_FMT_NV12M is only compatible with HEVC 8-bit\n");
 		return -EINVAL;
diff --git a/drivers/media/platform/meson/vdec/vdec.c b/drivers/media/platform/meson/vdec/vdec.c
index 6f53075..8863391 100644
--- a/drivers/media/platform/meson/vdec/vdec.c
+++ b/drivers/media/platform/meson/vdec/vdec.c
@@ -154,24 +154,25 @@ static int vdec_queue_setup(struct vb2_queue *q,
 {
 	struct vdec_session *sess = vb2_get_drv_priv(q);
 	const struct vdec_format *fmt_out = sess->fmt_out;
-	const struct vdec_format *fmt_cap = sess->fmt_cap;
+	u32 pixfmt_cap = sess->pixfmt_cap;
 	
 	switch (q->type) {
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
 		sizes[0] = vdec_get_output_size(sess);
 		sess->num_input_bufs = *num_buffers;
-		*num_planes = fmt_out->num_planes;
+		*num_planes = 1;
 		break;
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
-		if (fmt_cap->pixfmt == V4L2_PIX_FMT_NV12M) {
+		if (pixfmt_cap == V4L2_PIX_FMT_NV12M) {
 			sizes[0] = vdec_get_output_size(sess);
 			sizes[1] = vdec_get_output_size(sess) / 2;
-		} else if (fmt_cap->pixfmt == V4L2_PIX_FMT_YUV420M) {
+			*num_planes = 2;
+		} else if (pixfmt_cap == V4L2_PIX_FMT_YUV420M) {
 			sizes[0] = vdec_get_output_size(sess);
 			sizes[1] = vdec_get_output_size(sess) / 4;
 			sizes[2] = vdec_get_output_size(sess) / 4;
+			*num_planes = 3;
 		}
-		*num_planes = fmt_cap->num_planes;
 		*num_buffers = min(max(*num_buffers, fmt_out->min_buffers), fmt_out->max_buffers);
 		sess->num_output_bufs = *num_buffers;
 		break;
@@ -315,41 +316,28 @@ vdec_querycap(struct file *file, void *fh, struct v4l2_capability *cap)
 }
 
 static const struct vdec_format *
-find_format(const struct vdec_format *fmts, u32 size, u32 pixfmt, u32 type)
+find_format(const struct vdec_format *fmts, u32 size, u32 pixfmt)
 {
 	unsigned int i;
 
 	for (i = 0; i < size; i++) {
 		if (fmts[i].pixfmt == pixfmt)
-			break;
+			return &fmts[i];
 	}
 
-	if (i == size || fmts[i].type != type)
-		return NULL;
-
-	return &fmts[i];
+	return NULL;
 }
 
-static const struct vdec_format *
-find_format_by_index(const struct vdec_format *fmts, u32 size, u32 index, u32 type)
+static unsigned int
+vdec_supports_pixfmt_cap(const struct vdec_format *fmt_out, u32 pixfmt_cap)
 {
-	unsigned int i, k = 0;
-
-	if (index > size)
-		return NULL;
-
-	for (i = 0; i < size; i++) {
-		if (fmts[i].type != type)
-			continue;
-		if (k == index)
-			break;
-		k++;
-	}
+	int i;
 
-	if (i == size)
-		return NULL;
+	for (i = 0; fmt_out->pixfmts_cap[i]; i++)
+		if (fmt_out->pixfmts_cap[i] == pixfmt_cap)
+			return 1;
 
-	return &fmts[i];
+	return 0;
 }
 
 static const struct vdec_format *
@@ -358,45 +346,29 @@ vdec_try_fmt_common(struct vdec_session *sess, u32 size, struct v4l2_format *f)
 	struct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;
 	struct v4l2_plane_pix_format *pfmt = pixmp->plane_fmt;
 	const struct vdec_format *fmts = sess->core->platform->formats;
-	const struct vdec_format *fmt;
+	const struct vdec_format *fmt_out;
 
 	memset(pfmt[0].reserved, 0, sizeof(pfmt[0].reserved));
 	memset(pixmp->reserved, 0, sizeof(pixmp->reserved));
 
-	if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
-		/* hack: MJPEG only supports YUV420M */
-		if (sess->fmt_out->pixfmt == V4L2_PIX_FMT_MJPEG)
-			pixmp->pixelformat = V4L2_PIX_FMT_YUV420M;
-
-		/* hack: HEVC only supports NV12M */
-		if (sess->fmt_out->pixfmt == V4L2_PIX_FMT_HEVC)
-			pixmp->pixelformat = V4L2_PIX_FMT_NV12M;
-	}
-
-	fmt = find_format(fmts, size, pixmp->pixelformat, f->type);
-	if (!fmt) {
-		if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
-			pixmp->pixelformat = V4L2_PIX_FMT_NV12M;
-		else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		fmt_out = find_format(fmts, size, pixmp->pixelformat);
+		if (!fmt_out) {
 			pixmp->pixelformat = V4L2_PIX_FMT_H264;
-		else
-			return NULL;
-
-		fmt = find_format(fmts, size, pixmp->pixelformat, f->type);
-		pixmp->width = 1280;
-		pixmp->height = 720;
-	}
-
-	pixmp->width  = clamp(pixmp->width,  (u32)256, (u32)3840);
-	pixmp->height = clamp(pixmp->height, (u32)144, (u32)2160);
-
-	if (pixmp->field == V4L2_FIELD_ANY)
-		pixmp->field = V4L2_FIELD_NONE;
+			fmt_out = find_format(fmts, size, pixmp->pixelformat);
+			pixmp->width = 1280;
+			pixmp->height = 720;
+		}
 
-	pixmp->num_planes = fmt->num_planes;
-	pixmp->flags = 0;
+		pfmt[0].sizeimage =
+			get_output_size(pixmp->width, pixmp->height);
+		pfmt[0].bytesperline = 0;
+		pixmp->num_planes = 1;
+	} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+		fmt_out = sess->fmt_out;
+		if (!vdec_supports_pixfmt_cap(fmt_out, pixmp->pixelformat))
+			pixmp->pixelformat = fmt_out->pixfmts_cap[0];
 
-	if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
 		memset(pfmt[1].reserved, 0, sizeof(pfmt[1].reserved));
 		if (pixmp->pixelformat == V4L2_PIX_FMT_NV12M) {
 			pfmt[0].sizeimage =
@@ -406,6 +378,7 @@ vdec_try_fmt_common(struct vdec_session *sess, u32 size, struct v4l2_format *f)
 			pfmt[1].sizeimage =
 			      get_output_size(pixmp->width, pixmp->height) / 2;
 			pfmt[1].bytesperline = ALIGN(pixmp->width, 64);
+			pixmp->num_planes = 2;
 		} else if (pixmp->pixelformat == V4L2_PIX_FMT_YUV420M) {
 			pfmt[0].sizeimage =
 				get_output_size(pixmp->width, pixmp->height);
@@ -418,23 +391,29 @@ vdec_try_fmt_common(struct vdec_session *sess, u32 size, struct v4l2_format *f)
 			pfmt[2].sizeimage =
 			      get_output_size(pixmp->width, pixmp->height) / 4;
 			pfmt[2].bytesperline = ALIGN(pixmp->width, 64) / 2;
+			pixmp->num_planes = 3;
 		}
-	} else {
-		pfmt[0].sizeimage =
-			get_output_size(pixmp->width, pixmp->height);
-		pfmt[0].bytesperline = 0;
 	}
+	else
+		return NULL;
+
+	pixmp->width  = clamp(pixmp->width,  (u32)256, fmt_out->max_width);
+	pixmp->height = clamp(pixmp->height, (u32)144, fmt_out->max_height);
+
+	if (pixmp->field == V4L2_FIELD_ANY)
+		pixmp->field = V4L2_FIELD_NONE;
 
+	pixmp->flags = 0;
 
-	return fmt;
+	return fmt_out;
 }
 
 static int vdec_try_fmt(struct file *file, void *fh, struct v4l2_format *f)
 {
-	struct vdec_session *sess = container_of(file->private_data, struct vdec_session, fh);
+	struct vdec_session *sess =
+		container_of(file->private_data, struct vdec_session, fh);
 
-	vdec_try_fmt_common(sess,
-		sess->core->platform->num_formats, f);
+	vdec_try_fmt_common(sess, sess->core->platform->num_formats, f);
 
 	return 0;
 }
@@ -442,15 +421,12 @@ static int vdec_try_fmt(struct file *file, void *fh, struct v4l2_format *f)
 static int vdec_g_fmt(struct file *file, void *fh, struct v4l2_format *f)
 {
 	struct vdec_session *sess = container_of(file->private_data, struct vdec_session, fh);
-	const struct vdec_format *fmt = NULL;
 	struct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;
 
 	if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
-		fmt = sess->fmt_cap;
+		pixmp->pixelformat = sess->pixfmt_cap;
 	else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
-		fmt = sess->fmt_out;
-
-	pixmp->pixelformat = fmt->pixfmt;
+		pixmp->pixelformat = sess->fmt_out->pixfmt;
 
 	if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
 		pixmp->width = sess->width;
@@ -474,18 +450,18 @@ static int vdec_s_fmt(struct file *file, void *fh, struct v4l2_format *f)
 	struct vdec_session *sess = container_of(file->private_data, struct vdec_session, fh);
 	struct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;
 	u32 num_formats = sess->core->platform->num_formats;
-	const struct vdec_format *fmt;
+	const struct vdec_format *fmt_out;
 	struct v4l2_pix_format_mplane orig_pixmp;
 	struct v4l2_format format;
 	u32 pixfmt_out = 0, pixfmt_cap = 0;
 
 	orig_pixmp = *pixmp;
 
-	fmt = vdec_try_fmt_common(sess, num_formats, f);
+	fmt_out = vdec_try_fmt_common(sess, num_formats, f);
 
 	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
 		pixfmt_out = pixmp->pixelformat;
-		pixfmt_cap = sess->fmt_cap->pixfmt;
+		pixfmt_cap = sess->pixfmt_cap;
 	} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
 		pixfmt_cap = pixmp->pixelformat;
 		pixfmt_out = sess->fmt_out->pixfmt;
@@ -520,9 +496,9 @@ static int vdec_s_fmt(struct file *file, void *fh, struct v4l2_format *f)
 	sess->height = format.fmt.pix_mp.height;
 
 	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
-		sess->fmt_out = fmt;
+		sess->fmt_out = fmt_out;
 	else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
-		sess->fmt_cap = fmt;
+		sess->pixfmt_cap = format.fmt.pix_mp.pixelformat;
 
 	return 0;
 }
@@ -532,16 +508,24 @@ static int vdec_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)
 	struct vdec_session *sess =
 		container_of(file->private_data, struct vdec_session, fh);
 	const struct vdec_platform *platform = sess->core->platform;
-	const struct vdec_format *fmt;
+	const struct vdec_format *fmt_out;
 
 	memset(f->reserved, 0, sizeof(f->reserved));
 
-	fmt = find_format_by_index(platform->formats, platform->num_formats,
-				   f->index, f->type);
-	if (!fmt)
-		return -EINVAL;
+	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		if (f->index >= platform->num_formats)
+			return -EINVAL;
 
-	f->pixelformat = fmt->pixfmt;
+		fmt_out = &platform->formats[f->index];
+		f->pixelformat = fmt_out->pixfmt;
+	} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+		fmt_out = sess->fmt_out;
+		if (f->index >= 4 || !fmt_out->pixfmts_cap[f->index])
+			return -EINVAL;
+
+		f->pixelformat = fmt_out->pixfmts_cap[f->index];
+	} else
+		return -EINVAL;
 
 	return 0;
 }
@@ -552,17 +536,12 @@ static int vdec_enum_framesizes(struct file *file, void *fh,
 	struct vdec_session *sess =
 		container_of(file->private_data, struct vdec_session, fh);
 	const struct vdec_format *formats = sess->core->platform->formats;
-	u32 num_formats = sess->core->platform->num_formats;
 	const struct vdec_format *fmt;
+	u32 num_formats = sess->core->platform->num_formats;
 
-	fmt = find_format(formats, num_formats, fsize->pixel_format,
-			  V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
-	if (!fmt) {
-		fmt = find_format(formats, num_formats, fsize->pixel_format,
-				  V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
-		if (!fmt)
-			return -EINVAL;
-	}
+	fmt = find_format(formats, num_formats, fsize->pixel_format);
+	if (!fmt)
+		fmt = sess->fmt_out;
 
 	if (fsize->index)
 		return -EINVAL;
@@ -731,8 +710,8 @@ static int vdec_open(struct file *file)
 	mutex_unlock(&core->lock);
 
 	sess->core = core;
-	sess->fmt_cap = &formats[0];
-	sess->fmt_out = &formats[2];
+	sess->pixfmt_cap = formats[0].pixfmts_cap[0];
+	sess->fmt_out = &formats[0];
 	sess->width = 1280;
 	sess->height = 720;
 	INIT_LIST_HEAD(&sess->bufs);
diff --git a/drivers/media/platform/meson/vdec/vdec.h b/drivers/media/platform/meson/vdec/vdec.h
index 1a1d180..e1595f7 100644
--- a/drivers/media/platform/meson/vdec/vdec.h
+++ b/drivers/media/platform/meson/vdec/vdec.h
@@ -78,18 +78,19 @@ struct vdec_codec_ops {
 	irqreturn_t (*threaded_isr)(struct vdec_session *sess);
 };
 
-/* Describes one of the format that can be decoded/encoded */
+/* Describes one of the OUTPUT format that can be decoded */
 struct vdec_format {
 	u32 pixfmt;
-	u32 num_planes;
-	u32 type;
 	u32 min_buffers;
 	u32 max_buffers;
+	u32 max_width;
+	u32 max_height;
 
 	struct vdec_ops *vdec_ops;
 	struct vdec_codec_ops *codec_ops;
 
 	char *firmware_path;
+	u32 pixfmts_cap[4];
 };
 
 struct vdec_session {
@@ -102,7 +103,8 @@ struct vdec_session {
 	struct mutex codec_lock;
 	
 	const struct vdec_format *fmt_out;
-	const struct vdec_format *fmt_cap;
+	u32 pixfmt_cap;
+
 	u32 width;
 	u32 height;
 	u32 colorspace;
diff --git a/drivers/media/platform/meson/vdec/vdec_1.c b/drivers/media/platform/meson/vdec/vdec_1.c
index acf863d..78c0dd1 100644
--- a/drivers/media/platform/meson/vdec/vdec_1.c
+++ b/drivers/media/platform/meson/vdec/vdec_1.c
@@ -177,7 +177,7 @@ static int vdec_1_start(struct vdec_session *sess)
 	codec_ops->start(sess);
 
 	/* Enable 2-plane output */
-	if (sess->fmt_cap->pixfmt == V4L2_PIX_FMT_NV12M)
+	if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M)
 		writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) | (1 << 17), core->dos_base + MDEC_PIC_DC_CTRL);
 
 	/* Enable firmware processor */
diff --git a/drivers/media/platform/meson/vdec/vdec_platform.c b/drivers/media/platform/meson/vdec/vdec_platform.c
index 284fe0e..a250f8c 100644
--- a/drivers/media/platform/meson/vdec/vdec_platform.c
+++ b/drivers/media/platform/meson/vdec/vdec_platform.c
@@ -16,253 +16,253 @@
 
 static const struct vdec_format vdec_formats_gxbb[] = {
 	{
-		.pixfmt = V4L2_PIX_FMT_NV12M,
-		.num_planes = 2,
-		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
-	}, {
-		.pixfmt = V4L2_PIX_FMT_YUV420M,
-		.num_planes = 3,
-		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
-	}, {
 		.pixfmt = V4L2_PIX_FMT_H264,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 16,
 		.max_buffers = 32,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_h264_ops,
 		.firmware_path = "meson/gxbb/vh264_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_YUV420M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_HEVC,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 16,
 		.max_buffers = 24,
+		.max_width = 3840,
+		.max_height = 2160,
 		.vdec_ops = &vdec_hevc_ops,
 		.codec_ops = &codec_hevc_ops,
 		.firmware_path = "meson/gx/vh265_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG1,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg12_ops,
 		.firmware_path = "meson/gx/vmpeg12_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_YUV420M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG2,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg12_ops,
 		.firmware_path = "meson/gx/vmpeg12_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_YUV420M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG4,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg4_ops,
 		.firmware_path = "meson/gx/vmpeg4_mc_5",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_H263,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg4_ops,
 		.firmware_path = "meson/gx/h263_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_XVID,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg4_ops,
 		.firmware_path = "meson/gx/vmpeg4_mc_5",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MJPEG,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 4,
 		.max_buffers = 4,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mjpeg_ops,
 		.firmware_path = "meson/gx/vmjpeg_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_YUV420M, 0 },
 	},
 };
 
 static const struct vdec_format vdec_formats_gxl[] = {
 	{
-		.pixfmt = V4L2_PIX_FMT_NV12M,
-		.num_planes = 2,
-		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
-	}, {
-		.pixfmt = V4L2_PIX_FMT_YUV420M,
-		.num_planes = 3,
-		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
-	}, {
 		.pixfmt = V4L2_PIX_FMT_H264,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 16,
 		.max_buffers = 32,
+		.max_width = 3840,
+		.max_height = 2160,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_h264_ops,
 		.firmware_path = "meson/gxl/vh264_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_YUV420M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_HEVC,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 16,
 		.max_buffers = 24,
+		.max_width = 3840,
+		.max_height = 2160,
 		.vdec_ops = &vdec_hevc_ops,
 		.codec_ops = &codec_hevc_ops,
 		.firmware_path = "meson/gx/vh265_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG1,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg12_ops,
 		.firmware_path = "meson/gx/vmpeg12_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_YUV420M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG2,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg12_ops,
 		.firmware_path = "meson/gx/vmpeg12_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_YUV420M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG4,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg4_ops,
 		.firmware_path = "meson/gx/vmpeg4_mc_5",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_H263,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg4_ops,
 		.firmware_path = "meson/gx/h263_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_XVID,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg4_ops,
 		.firmware_path = "meson/gx/vmpeg4_mc_5",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MJPEG,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 4,
 		.max_buffers = 4,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mjpeg_ops,
 		.firmware_path = "meson/gx/vmjpeg_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_YUV420M, 0 },
 	},
 };
 
 static const struct vdec_format vdec_formats_gxm[] = {
 	{
-		.pixfmt = V4L2_PIX_FMT_NV12M,
-		.num_planes = 2,
-		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
-	}, {
-		.pixfmt = V4L2_PIX_FMT_YUV420M,
-		.num_planes = 3,
-		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
-	}, {
 		.pixfmt = V4L2_PIX_FMT_H264,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 16,
 		.max_buffers = 32,
+		.max_width = 3840,
+		.max_height = 2160,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_h264_ops,
 		.firmware_path = "meson/gxm/vh264_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_YUV420M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_HEVC,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 16,
 		.max_buffers = 24,
+		.max_width = 3840,
+		.max_height = 2160,
 		.vdec_ops = &vdec_hevc_ops,
 		.codec_ops = &codec_hevc_ops,
 		.firmware_path = "meson/gx/vh265_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG1,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg12_ops,
 		.firmware_path = "meson/gx/vmpeg12_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_YUV420M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG2,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg12_ops,
 		.firmware_path = "meson/gx/vmpeg12_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_YUV420M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG4,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg4_ops,
 		.firmware_path = "meson/gx/vmpeg4_mc_5",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_H263,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg4_ops,
 		.firmware_path = "meson/gx/h263_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_XVID,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 8,
 		.max_buffers = 8,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mpeg4_ops,
 		.firmware_path = "meson/gx/vmpeg4_mc_5",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MJPEG,
-		.num_planes = 1,
-		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.min_buffers = 4,
 		.max_buffers = 4,
+		.max_width = 1920,
+		.max_height = 1080,
 		.vdec_ops = &vdec_1_ops,
 		.codec_ops = &codec_mjpeg_ops,
 		.firmware_path = "meson/gx/vmjpeg_mc",
+		.pixfmts_cap = { V4L2_PIX_FMT_YUV420M, 0 },
 	},
 };
 
-- 
2.7.4

