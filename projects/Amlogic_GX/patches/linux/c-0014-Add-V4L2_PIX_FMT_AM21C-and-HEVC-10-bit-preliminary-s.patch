From c5692e3ce01b8a6fc96159f287223ff68cb9fce4 Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <maxi.jourdan@wanadoo.fr>
Date: Fri, 17 Aug 2018 09:05:59 +0200
Subject: [PATCH 14/35] Add V4L2_PIX_FMT_AM21C and HEVC 10-bit preliminary
 support

V4L2_PIX_FMT_AM21C is a pixel format for Amlogic's frame buffer
compression technology. The internals are unknown.

This pixfmt is mandatory for HEVC 10-bit.

This is 100% untested, pretty sure I'm missing something.
---
 drivers/media/platform/meson/vdec/codec_helpers.c | 24 +++++++
 drivers/media/platform/meson/vdec/codec_helpers.h |  3 +
 drivers/media/platform/meson/vdec/codec_hevc.c    | 87 ++++++++++++++---------
 drivers/media/platform/meson/vdec/vdec.c          |  9 ++-
 drivers/media/platform/meson/vdec/vdec_platform.c |  6 +-
 include/uapi/linux/videodev2.h                    |  1 +
 6 files changed, 91 insertions(+), 39 deletions(-)

diff --git a/drivers/media/platform/meson/vdec/codec_helpers.c b/drivers/media/platform/meson/vdec/codec_helpers.c
index 0ba355e..5e3fed5 100644
--- a/drivers/media/platform/meson/vdec/codec_helpers.c
+++ b/drivers/media/platform/meson/vdec/codec_helpers.c
@@ -9,6 +9,30 @@
 #include "codec_helpers.h"
 #include "canvas.h"
 
+/* 4 KiB per 64x32 block */
+u32 codec_am21c_body_size(u32 width, u32 height)
+{
+	u32 width_64 = ALIGN(width, 64) / 64;
+	u32 height_32 = ALIGN(height, 32) / 32;
+
+	return SZ_4K * width_64 * height_32;
+}
+
+/* 32 bytes per 128x64 block */
+u32 codec_am21c_head_size(u32 width, u32 height)
+{
+	u32 width_128 = ALIGN(width, 128) / 128;
+	u32 height_64 = ALIGN(height, 64) / 64;
+
+	return 32 * width_128 * height_64;
+}
+
+u32 codec_am21c_size(u32 width, u32 height)
+{
+	return ALIGN(codec_am21c_body_size(width, height) +
+		     codec_am21c_head_size(width, height), SZ_64K);
+}
+
 void
 codec_helper_set_canvases_yuv420m(struct vdec_session *sess, void *reg_base)
 {
diff --git a/drivers/media/platform/meson/vdec/codec_helpers.h b/drivers/media/platform/meson/vdec/codec_helpers.h
index 0a778ba..96c3cc5 100644
--- a/drivers/media/platform/meson/vdec/codec_helpers.h
+++ b/drivers/media/platform/meson/vdec/codec_helpers.h
@@ -4,5 +4,8 @@
 #include "vdec.h"
 
 void codec_helper_set_canvases(struct vdec_session *sess, void *reg_base);
+u32 codec_am21c_body_size(u32 width, u32 height);
+u32 codec_am21c_head_size(u32 width, u32 height);
+u32 codec_am21c_size(u32 width, u32 height);
 
 #endif
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/codec_hevc.c b/drivers/media/platform/meson/vdec/codec_hevc.c
index e7e4fb7..09fe106 100644
--- a/drivers/media/platform/meson/vdec/codec_hevc.c
+++ b/drivers/media/platform/meson/vdec/codec_hevc.c
@@ -11,6 +11,7 @@
 #include "canvas.h"
 #include "dos_regs.h"
 #include "hevc_regs.h"
+#include "codec_helpers.h"
 
 /* HEVC reg mapping */
 #define HEVC_DEC_STATUS_REG	HEVC_ASSIST_SCRATCH_0
@@ -505,24 +506,25 @@ static void codec_hevc_output_frames(struct vdec_session *sess)
 	}
 }
 
-/* Configure part of the IP responsible for frame buffer decompression */
+/* Configure frame buffer decompression */
 static void codec_hevc_setup_decode_head(struct vdec_session *sess)
 {
 	struct vdec_core *core = sess->core;
+	u32 body_size = codec_am21c_body_size(sess->width, sess->height);
+	u32 head_size = codec_am21c_head_size(sess->width, sess->height);
 
-	/* TODO */
 	writel_relaxed(0, core->dos_base + HEVCD_MPP_DECOMP_CTL1);
-	writel_relaxed(0, core->dos_base + HEVCD_MPP_DECOMP_CTL2);
-	writel_relaxed(0, core->dos_base + HEVC_CM_BODY_LENGTH);
-	writel_relaxed(0, core->dos_base + HEVC_CM_HEADER_OFFSET);
-	writel_relaxed(0, core->dos_base + HEVC_CM_HEADER_LENGTH);
+	writel_relaxed(body_size / 32, core->dos_base + HEVCD_MPP_DECOMP_CTL2);
+	writel_relaxed(body_size, core->dos_base + HEVC_CM_BODY_LENGTH);
+	writel_relaxed(body_size, core->dos_base + HEVC_CM_HEADER_OFFSET);
+	writel_relaxed(head_size, core->dos_base + HEVC_CM_HEADER_LENGTH);
 }
 
 static void codec_hevc_setup_buffers_gxbb(struct vdec_session *sess)
 {
 	struct vdec_core *core = sess->core;
 	struct v4l2_m2m_buffer *buf;
-	u32 buf_size = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
+	u32 buf_num = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
 	dma_addr_t buf_y_paddr = 0;
 	dma_addr_t buf_uv_paddr = 0;
 	u32 idx = 0;
@@ -534,17 +536,22 @@ static void codec_hevc_setup_buffers_gxbb(struct vdec_session *sess)
 	v4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {
 		idx = buf->vb.vb2_buf.index;
 		buf_y_paddr  = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
-		buf_uv_paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
 
-		val = buf_y_paddr | ((idx * 2) << 8) | 1;
-		writel_relaxed(val, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR);
-		val = buf_uv_paddr | ((idx * 2 + 1) << 8) | 1;
-		writel_relaxed(val, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR);
+		if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M) {
+			buf_uv_paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
+			val = buf_y_paddr | ((idx * 2) << 8) | 1;
+			writel_relaxed(val, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR);
+			val = buf_uv_paddr | ((idx * 2 + 1) << 8) | 1;
+			writel_relaxed(val, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR);
+		} else if (sess->pixfmt_cap == V4L2_PIX_FMT_AM21C) {
+			val = buf_y_paddr | (idx << 8) | 1;
+			writel_relaxed(val, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR);
+		}
 	}
 
 	val = buf_y_paddr | ((idx * 2) << 8) | 1;
 	/* Fill the remaining unused slots with the last buffer's Y addr */
-	for (i = buf_size; i < MAX_REF_PIC_NUM; ++i)
+	for (i = buf_num; i < MAX_REF_PIC_NUM; ++i)
 		writel_relaxed(val, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR);
 
 	writel_relaxed(1, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR);
@@ -557,7 +564,7 @@ static void codec_hevc_setup_buffers_gxl(struct vdec_session *sess)
 {
 	struct vdec_core *core = sess->core;
 	struct v4l2_m2m_buffer *buf;
-	u32 buf_size = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
+	u32 buf_num = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
 	dma_addr_t buf_y_paddr = 0;
 	dma_addr_t buf_uv_paddr = 0;
 	int i;
@@ -566,15 +573,19 @@ static void codec_hevc_setup_buffers_gxl(struct vdec_session *sess)
 
 	v4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {
 		buf_y_paddr  = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
-		buf_uv_paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
-
-		writel_relaxed(buf_y_paddr  >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
-		writel_relaxed(buf_uv_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
+		writel_relaxed(buf_y_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
+		if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M) {
+			buf_uv_paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
+			writel_relaxed(buf_uv_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
+		}
 	}
 
 	/* Fill the remaining unused slots with the last buffer's Y addr */
-	for (i = buf_size; i < MAX_REF_PIC_NUM; ++i)
-		writel_relaxed(buf_y_paddr  >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
+	for (i = buf_num; i < MAX_REF_PIC_NUM; ++i) {
+		writel_relaxed(buf_y_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
+		if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M)
+			writel_relaxed(buf_uv_paddr >> 5, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_DATA);
+	}
 
 	writel_relaxed(1, core->dos_base + HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR);
 	writel_relaxed(1, core->dos_base + HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR);
@@ -714,7 +725,7 @@ static int codec_hevc_start(struct vdec_session *sess)
 	else
 		codec_hevc_setup_buffers_gxl(sess);
 
-	if (sess->pixfmt_cap != V4L2_PIX_FMT_NV12M)
+	if (sess->pixfmt_cap == V4L2_PIX_FMT_AM21C)
 		codec_hevc_setup_decode_head(sess);
 
 	return 0;
@@ -852,7 +863,7 @@ static void codec_hevc_set_sao(struct vdec_session *sess, struct hevc_frame *fra
 	struct codec_hevc *hevc = sess->priv;
 	union rpm_param *param = &hevc->rpm_param;
 	dma_addr_t buf_y_paddr = vb2_dma_contig_plane_dma_addr(&frame->vbuf->vb2_buf, 0);
-	dma_addr_t buf_u_v_paddr = vb2_dma_contig_plane_dma_addr(&frame->vbuf->vb2_buf, 1);
+	dma_addr_t buf_u_v_paddr;
 	u32 misc_flag0 = param->p.misc_flag0;
 	u32 slice_deblocking_filter_disabled_flag;
 	u32 val, val_2;
@@ -863,14 +874,18 @@ static void codec_hevc_set_sao(struct vdec_session *sess, struct hevc_frame *fra
 	writel_relaxed(hevc->width | (hevc->height << 16), core->dos_base + HEVC_SAO_PIC_SIZE);
 	writel_relaxed((hevc->lcu_x_num - 1) | (hevc->lcu_y_num - 1) << 16, core->dos_base + HEVC_SAO_PIC_SIZE_LCU);
 
-	writel_relaxed(buf_y_paddr, core->dos_base + HEVC_SAO_Y_START_ADDR);
+	if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M) {
+		buf_u_v_paddr = vb2_dma_contig_plane_dma_addr(&frame->vbuf->vb2_buf, 1);
+		writel_relaxed(buf_y_paddr, core->dos_base + HEVC_SAO_Y_START_ADDR);
+		writel_relaxed(buf_u_v_paddr, core->dos_base + HEVC_SAO_C_START_ADDR);
+		writel_relaxed(buf_y_paddr, core->dos_base + HEVC_SAO_Y_WPTR);
+		writel_relaxed(buf_u_v_paddr, core->dos_base + HEVC_SAO_C_WPTR);
+	} else if (sess->pixfmt_cap == V4L2_PIX_FMT_AM21C) {
+		writel_relaxed(buf_y_paddr, core->dos_base + HEVC_CM_BODY_START_ADDR);
+	}
 	writel_relaxed(vdec_get_output_size(sess), core->dos_base + HEVC_SAO_Y_LENGTH);
-	writel_relaxed(buf_u_v_paddr, core->dos_base + HEVC_SAO_C_START_ADDR);
 	writel_relaxed((vdec_get_output_size(sess) / 2), core->dos_base + HEVC_SAO_C_LENGTH);
 
-	writel_relaxed(buf_y_paddr, core->dos_base + HEVC_SAO_Y_WPTR);
-	writel_relaxed(buf_u_v_paddr, core->dos_base + HEVC_SAO_C_WPTR);
-
 	if (frame->cur_slice_idx == 0) {
 		writel_relaxed(hevc->width | (hevc->height << 16), core->dos_base + HEVC_DBLK_CFG2);
 
@@ -887,21 +902,23 @@ static void codec_hevc_set_sao(struct vdec_session *sess, struct hevc_frame *fra
 	val = readl_relaxed(core->dos_base + HEVC_SAO_CTRL1) & ~0x3ff3;
 	if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M)
 		val |= 0xff0 | /* Set endianness for 2-bytes swaps (nv12) */
-			0x1;   /* disable cm compression */
+			 0x1;   /* disable cm compression */
 	else
 		val |= 0x3000 | /* 64x32 block mode */
 			0x880 | /* 64-bit Big Endian */
-			0x2;    /* Disable double write */
+			  0x2;    /* Disable double write */
 
 	writel_relaxed(val, core->dos_base + HEVC_SAO_CTRL1);
 
-	/* set them all 0 for H265_NV21 (no down-scale) */
-	val = readl_relaxed(core->dos_base + HEVC_SAO_CTRL5) & ~0xff0000;
-	writel_relaxed(val, core->dos_base + HEVC_SAO_CTRL5);
+	if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M) {
+		/* no downscale for NV12 */
+		val = readl_relaxed(core->dos_base + HEVC_SAO_CTRL5) & ~0xff0000;
+		writel_relaxed(val, core->dos_base + HEVC_SAO_CTRL5);
+	}
 
 	val = readl_relaxed(core->dos_base + HEVCD_IPP_AXIIF_CONFIG) & ~0x30;
 	val |= 0xf;
-	if (sess->pixfmt_cap != V4L2_PIX_FMT_NV12M)
+	if (sess->pixfmt_cap == V4L2_PIX_FMT_AM21C)
 		val |= 0x30; /* 64x32 block mode */
 
 	writel_relaxed(val, core->dos_base + HEVCD_IPP_AXIIF_CONFIG);
@@ -1291,9 +1308,9 @@ static int codec_hevc_process_rpm(struct vdec_session *sess)
 	u32 lcu_x_num_div, lcu_y_num_div;
 
 	if (rpm_param->p.bit_depth &&
-	    sess->pixfmt_cap == V4L2_PIX_FMT_NV12M) {
+	    sess->pixfmt_cap != V4L2_PIX_FMT_AM21C) {
 		dev_err(sess->core->dev_dec,
-		    "V4L2_PIX_FMT_NV12M is only compatible with HEVC 8-bit\n");
+		   "HEVC 10-bit is only compatible with V4L2_PIX_FMT_AM21C\n");
 		return -EINVAL;
 	}
 
diff --git a/drivers/media/platform/meson/vdec/vdec.c b/drivers/media/platform/meson/vdec/vdec.c
index 8863391..2d75dc4 100644
--- a/drivers/media/platform/meson/vdec/vdec.c
+++ b/drivers/media/platform/meson/vdec/vdec.c
@@ -22,8 +22,8 @@
 #include "vdec.h"
 #include "esparser.h"
 #include "canvas.h"
-
 #include "vdec_1.h"
+#include "codec_helpers.h"
 
 /* 16 MiB for parsed bitstream swap exchange */
 #define SIZE_VIFIFO (16 * SZ_1M)
@@ -172,6 +172,9 @@ static int vdec_queue_setup(struct vb2_queue *q,
 			sizes[1] = vdec_get_output_size(sess) / 4;
 			sizes[2] = vdec_get_output_size(sess) / 4;
 			*num_planes = 3;
+		} else if (pixfmt_cap == V4L2_PIX_FMT_AM21C) {
+			sizes[0] = codec_am21c_size(sess->width, sess->height);
+			*num_planes = 1;
 		}
 		*num_buffers = min(max(*num_buffers, fmt_out->min_buffers), fmt_out->max_buffers);
 		sess->num_output_bufs = *num_buffers;
@@ -392,6 +395,10 @@ vdec_try_fmt_common(struct vdec_session *sess, u32 size, struct v4l2_format *f)
 			      get_output_size(pixmp->width, pixmp->height) / 4;
 			pfmt[2].bytesperline = ALIGN(pixmp->width, 64) / 2;
 			pixmp->num_planes = 3;
+		} else if (pixmp->pixelformat == V4L2_PIX_FMT_AM21C) {
+			pfmt[0].sizeimage =
+				codec_am21c_size(pixmp->width, pixmp->height);
+			pfmt[0].bytesperline = 0;
 		}
 	}
 	else
diff --git a/drivers/media/platform/meson/vdec/vdec_platform.c b/drivers/media/platform/meson/vdec/vdec_platform.c
index a250f8c..91277e0 100644
--- a/drivers/media/platform/meson/vdec/vdec_platform.c
+++ b/drivers/media/platform/meson/vdec/vdec_platform.c
@@ -34,7 +34,7 @@ static const struct vdec_format vdec_formats_gxbb[] = {
 		.vdec_ops = &vdec_hevc_ops,
 		.codec_ops = &codec_hevc_ops,
 		.firmware_path = "meson/gx/vh265_mc",
-		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_AM21C, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG1,
 		.min_buffers = 8,
@@ -118,7 +118,7 @@ static const struct vdec_format vdec_formats_gxl[] = {
 		.vdec_ops = &vdec_hevc_ops,
 		.codec_ops = &codec_hevc_ops,
 		.firmware_path = "meson/gx/vh265_mc",
-		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_AM21C, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG1,
 		.min_buffers = 8,
@@ -202,7 +202,7 @@ static const struct vdec_format vdec_formats_gxm[] = {
 		.vdec_ops = &vdec_hevc_ops,
 		.codec_ops = &codec_hevc_ops,
 		.firmware_path = "meson/gx/vh265_mc",
-		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, V4L2_PIX_FMT_AM21C, 0 },
 	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG1,
 		.min_buffers = 8,
diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
index 600877b..0568053 100644
--- a/include/uapi/linux/videodev2.h
+++ b/include/uapi/linux/videodev2.h
@@ -668,6 +668,7 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_Y12I     v4l2_fourcc('Y', '1', '2', 'I') /* Greyscale 12-bit L/R interleaved */
 #define V4L2_PIX_FMT_Z16      v4l2_fourcc('Z', '1', '6', ' ') /* Depth data 16-bit */
 #define V4L2_PIX_FMT_MT21C    v4l2_fourcc('M', 'T', '2', '1') /* Mediatek compressed block mode  */
+#define V4L2_PIX_FMT_AM21C    v4l2_fourcc('A', 'M', '2', '1') /* Amlogic compressed block mode  */
 #define V4L2_PIX_FMT_INZI     v4l2_fourcc('I', 'N', 'Z', 'I') /* Intel Planar Greyscale 10-bit and Depth 16-bit */
 
 /* 10bit raw bayer packed, 32 bytes for every 25 pixels, last LSB 6 bits unused */
-- 
2.7.4

