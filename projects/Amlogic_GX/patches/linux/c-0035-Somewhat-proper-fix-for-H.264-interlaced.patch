From 9620a995dbce9cf39822eac734aef38b5dd391d2 Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <mjourdan@baylibre.com>
Date: Sat, 25 Aug 2018 19:41:36 +0200
Subject: [PATCH 35/35] Somewhat proper fix for H.264 interlaced

This at least fixes all the 1080i H.264 samples I have..
---
 drivers/media/platform/meson/vdec/codec_h264.c | 15 +++++++++++++--
 drivers/media/platform/meson/vdec/vdec.c       |  6 +++---
 drivers/media/platform/meson/vdec/vdec.h       |  1 +
 3 files changed, 17 insertions(+), 5 deletions(-)

diff --git a/drivers/media/platform/meson/vdec/codec_h264.c b/drivers/media/platform/meson/vdec/codec_h264.c
index c82757f..d10e8ae 100644
--- a/drivers/media/platform/meson/vdec/codec_h264.c
+++ b/drivers/media/platform/meson/vdec/codec_h264.c
@@ -57,6 +57,8 @@ struct codec_h264 {
 	/* Buffer for parsed SEI data */
 	void      *sei_vaddr;
 	dma_addr_t sei_paddr;
+
+	int received_0;
 };
 
 static int codec_h264_can_recycle(struct amvdec_core *core)
@@ -242,6 +244,7 @@ static void codec_h264_set_param(struct amvdec_session *sess) {
 static void codec_h264_frames_ready(struct amvdec_session *sess, u32 status)
 {
 	struct amvdec_core *core = sess->core;
+	struct codec_h264 *h264 = sess->priv;
 	int error_count;
 	int num_frames;
 	int i;
@@ -275,12 +278,18 @@ static void codec_h264_frames_ready(struct amvdec_session *sess, u32 status)
 			field = V4L2_FIELD_INTERLACED_BT;
 
 		amvdec_dst_buf_done_idx(sess, buffer_index, field);
+
+		if (field != V4L2_FIELD_NONE && !h264->received_0)
+			amvdec_rm_first_ts(sess);
+
+		h264->received_0 = 0;
 	}
 }
 
 static irqreturn_t codec_h264_threaded_isr(struct amvdec_session *sess)
 {
 	struct amvdec_core *core = sess->core;
+	struct codec_h264 *h264 = sess->priv;
 	u32 status;
 	u32 size;
 	u8 cmd;
@@ -306,8 +315,10 @@ static irqreturn_t codec_h264_threaded_isr(struct amvdec_session *sess)
 		size = (amvdec_read_dos(core, AV_SCRATCH_1) + 1) * 16;
 		dev_err(core->dev, "Unsupported video height: %u\n", size);
 		goto abort;
-	case 0: /* Unused but not worth printing for */
-	case 9:
+	case 0:
+		h264->received_0 = 1;
+		break;
+	case 9: /* Unused but not worth printing for */
 		break;
 	default:
 		dev_info(core->dev, "Unexpected H264 ISR: %08X\n", cmd);
diff --git a/drivers/media/platform/meson/vdec/vdec.c b/drivers/media/platform/meson/vdec/vdec.c
index dce159c..14694aa 100644
--- a/drivers/media/platform/meson/vdec/vdec.c
+++ b/drivers/media/platform/meson/vdec/vdec.c
@@ -790,7 +790,7 @@ static int vdec_close(struct file *file)
 	return 0;
 }
 
-static void vdec_rm_first_ts(struct amvdec_session *sess)
+void amvdec_rm_first_ts(struct amvdec_session *sess)
 {
 	unsigned long flags;
 	struct amvdec_buffer *tmp;
@@ -805,6 +805,7 @@ static void vdec_rm_first_ts(struct amvdec_session *sess)
 	tmp = list_first_entry(&sess->bufs, struct amvdec_buffer, list);
 	list_del(&tmp->list);
 	kfree(tmp);
+	atomic_dec(&sess->esparser_queued_bufs);
 
 unlock:
 	spin_unlock_irqrestore(&sess->bufs_spinlock, flags);
@@ -883,8 +884,7 @@ amvdec_dst_buf_done_idx(struct amvdec_session *sess, u32 buf_idx, u32 field)
 	if (!vbuf) {
 		dev_err(dev, "Buffer %u done but it doesn't exist in m2m_ctx\n",
 			buf_idx);
-		atomic_dec(&sess->esparser_queued_bufs);
-		vdec_rm_first_ts(sess);
+		amvdec_rm_first_ts(sess);
 		return;
 	}
 
diff --git a/drivers/media/platform/meson/vdec/vdec.h b/drivers/media/platform/meson/vdec/vdec.h
index 2ec8bce..cc7ee79 100644
--- a/drivers/media/platform/meson/vdec/vdec.h
+++ b/drivers/media/platform/meson/vdec/vdec.h
@@ -167,6 +167,7 @@ void amvdec_dst_buf_done_idx(struct amvdec_session *sess, u32 buf_idx, u32 field
 void amvdec_dst_buf_done(struct amvdec_session *sess, struct vb2_v4l2_buffer *vbuf, u32 field);
 void amvdec_add_ts_reorder(struct amvdec_session *sess, u64 ts);
 void amvdec_remove_ts(struct amvdec_session *sess, u64 ts);
+void amvdec_rm_first_ts(struct amvdec_session *sess);
 void amvdec_abort(struct amvdec_session *sess);
 
 u32 amvdec_read_dos(struct amvdec_core *core, u32 reg);
-- 
2.7.4

