From dacb176d1c59afade440a0503e0135debb351529 Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <maxi.jourdan@wanadoo.fr>
Date: Tue, 21 Aug 2018 10:44:50 +0200
Subject: [PATCH 23/35] Cleanups + fixes

* Split some 80+ col lines, remove more DOS_SW_RESET0 writes, move
register defines to dos_regs.h
* Remove the 2 minimum recycle buf num. It's a hack that was added to
workaround a userspace bug.
* Revert "Fix EOS signaling on VDEC_1 codecs" as it was introduced by
the previous point
* Bump the minimum H.264 buffers to 21 to prevent freezes on some
samples.
---
 drivers/media/platform/meson/vdec/codec_h264.c    | 57 ++++++++++++-----------
 drivers/media/platform/meson/vdec/codec_mjpeg.c   |  3 --
 drivers/media/platform/meson/vdec/dos_regs.h      | 17 +++++++
 drivers/media/platform/meson/vdec/esparser.c      |  7 ++-
 drivers/media/platform/meson/vdec/vdec.c          |  6 +--
 drivers/media/platform/meson/vdec/vdec.h          |  1 -
 drivers/media/platform/meson/vdec/vdec_1.c        | 17 -------
 drivers/media/platform/meson/vdec/vdec_platform.c |  6 +--
 8 files changed, 57 insertions(+), 57 deletions(-)

diff --git a/drivers/media/platform/meson/vdec/codec_h264.c b/drivers/media/platform/meson/vdec/codec_h264.c
index d8e5299..2f1cfd8 100644
--- a/drivers/media/platform/meson/vdec/codec_h264.c
+++ b/drivers/media/platform/meson/vdec/codec_h264.c
@@ -29,8 +29,11 @@
 #define CMD_BAD_WIDTH		7
 #define CMD_BAD_HEIGHT		8
 
+/* Size of Motion Vector per macroblock */
+#define MB_MV_SIZE 96
+
 struct codec_h264 {
-	/* H.264 decoder requires an extended firmware loaded in contiguous RAM */
+	/* H.264 decoder requires an extended firmware */
 	void      *ext_fw_vaddr;
 	dma_addr_t ext_fw_paddr;
 
@@ -107,11 +110,6 @@ static int codec_h264_start(struct amvdec_session *sess) {
 	amvdec_write_dos(core, AV_SCRATCH_F, (amvdec_read_dos(core, AV_SCRATCH_F) & 0xffffffc3) | (1 << 4) | (1 << 7));
 
 	amvdec_write_dos(core, MDEC_PIC_DC_THRESH, 0x404038aa);
-	
-	amvdec_write_dos(core, DOS_SW_RESET0, (1<<12)|(1<<11));
-	amvdec_write_dos(core, DOS_SW_RESET0, 0);
-
-	amvdec_read_dos(core, DOS_SW_RESET0);
 	return 0;
 }
 
@@ -121,16 +119,20 @@ static int codec_h264_stop(struct amvdec_session *sess)
 	struct amvdec_core *core = sess->core;
 
 	if (h264->ext_fw_vaddr)
-		dma_free_coherent(core->dev, SIZE_EXT_FW, h264->ext_fw_vaddr, h264->ext_fw_paddr);
+		dma_free_coherent(core->dev, SIZE_EXT_FW,
+				  h264->ext_fw_vaddr, h264->ext_fw_paddr);
 	
 	if (h264->workspace_vaddr)
-		dma_free_coherent(core->dev, SIZE_WORKSPACE, h264->workspace_vaddr, h264->workspace_paddr);
+		dma_free_coherent(core->dev, SIZE_WORKSPACE,
+				  h264->workspace_vaddr, h264->workspace_paddr);
 	
 	if (h264->ref_vaddr)
-		dma_free_coherent(core->dev, h264->ref_size, h264->ref_vaddr, h264->ref_paddr);
+		dma_free_coherent(core->dev, h264->ref_size,
+				  h264->ref_vaddr, h264->ref_paddr);
 	
 	if (h264->sei_vaddr)
-		dma_free_coherent(core->dev, SIZE_SEI, h264->sei_vaddr, h264->sei_paddr);
+		dma_free_coherent(core->dev, SIZE_SEI,
+				  h264->sei_vaddr, h264->sei_paddr);
 	
 	return 0;
 }
@@ -149,9 +151,11 @@ static int codec_h264_load_extended_firmware(struct amvdec_session *sess, const
 	if (len != SIZE_EXT_FW)
 		return -EINVAL;
 	
-	h264->ext_fw_vaddr = dma_alloc_coherent(core->dev, SIZE_EXT_FW, &h264->ext_fw_paddr, GFP_KERNEL);
+	h264->ext_fw_vaddr = dma_alloc_coherent(core->dev, SIZE_EXT_FW,
+						&h264->ext_fw_paddr, GFP_KERNEL);
 	if (!h264->ext_fw_vaddr) {
-		dev_err(core->dev, "Couldn't allocate memory for H.264 extended firmware\n");
+		dev_err(core->dev,
+			"Couldn't allocate memory for H.264 extended fw\n");
 		return -ENOMEM;
 	}
 
@@ -161,16 +165,15 @@ static int codec_h264_load_extended_firmware(struct amvdec_session *sess, const
 }
 
 /* Configure the H.264 decoder when the esparser finished parsing
- * the first buffer.
+ * the first keyframe
  */
 static void codec_h264_set_param(struct amvdec_session *sess) {
+	struct amvdec_core *core = sess->core;
+	struct codec_h264 *h264 = sess->priv;
 	u32 max_reference_size;
 	u32 parsed_info, mb_width, mb_height, mb_total;
-	u32 mb_mv_byte;
 	u32 actual_dpb_size = v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
 	u32 max_dpb_size = 4;
-	struct amvdec_core *core = sess->core;
-	struct codec_h264 *h264 = sess->priv;
 
 	sess->keyframe_found = 1;
 
@@ -183,9 +186,6 @@ static void codec_h264_set_param(struct amvdec_session *sess) {
 	/* Total number of 16x16 macroblocks */
 	mb_total = (parsed_info >> 8) & 0xffff;
 
-	/* Size of Motion Vector per macroblock ? */
-	mb_mv_byte = 96;
-
 	/* Number of macroblocks per line */
 	mb_width = parsed_info & 0xff;
 
@@ -195,8 +195,8 @@ static void codec_h264_set_param(struct amvdec_session *sess) {
 	max_reference_size = (parsed_info >> 24) & 0x7f;
 
 	/* Align to a multiple of 4 macroblocks */
-	mb_width = (mb_width + 3) & 0xfffffffc;
-	mb_height = (mb_height + 3) & 0xfffffffc;
+	mb_width = ALIGN(mb_width, 4);
+	mb_height = ALIGN(mb_height, 4);
 	mb_total = mb_width * mb_height;
 
 	amcodec_helper_set_canvases(sess, core->dos_base + ANC0_CANVAS_ADDR);
@@ -209,19 +209,24 @@ static void codec_h264_set_param(struct amvdec_session *sess) {
 		"max_ref_size = %u; max_dpb_size = %u; actual_dpb_size = %u\n",
 		max_reference_size, max_dpb_size, actual_dpb_size);
 
-	h264->ref_size = mb_total * mb_mv_byte * max_reference_size;
-	h264->ref_vaddr = dma_alloc_coherent(core->dev, h264->ref_size, &h264->ref_paddr, GFP_KERNEL);
+	h264->ref_size = mb_total * MB_MV_SIZE * max_reference_size;
+	h264->ref_vaddr = dma_alloc_coherent(core->dev, h264->ref_size,
+					     &h264->ref_paddr, GFP_KERNEL);
 	if (!h264->ref_vaddr) {
-		dev_err(core->dev, "Failed to allocate memory for refs (%u)\n", h264->ref_size);
+		dev_err(core->dev, "Failed to allocate memory for refs (%u)\n",
+			h264->ref_size);
 		amvdec_abort(sess);
 		return;
 	}
 
-	/* Address to store the references' MVs ? */
+	/* Address to store the references' MVs */
 	amvdec_write_dos(core, AV_SCRATCH_1, h264->ref_paddr);
 	/* End of ref MV */
 	amvdec_write_dos(core, AV_SCRATCH_4, h264->ref_paddr + h264->ref_size);
-	amvdec_write_dos(core, AV_SCRATCH_0, (max_reference_size << 24) | (actual_dpb_size << 16) | (max_dpb_size << 8));
+
+	amvdec_write_dos(core, AV_SCRATCH_0, (max_reference_size << 24) |
+					     (actual_dpb_size << 16) |
+					     (max_dpb_size << 8));
 }
 
 static void codec_h264_frames_ready(struct amvdec_session *sess, u32 status)
diff --git a/drivers/media/platform/meson/vdec/codec_mjpeg.c b/drivers/media/platform/meson/vdec/codec_mjpeg.c
index f79b288..e98df88 100644
--- a/drivers/media/platform/meson/vdec/codec_mjpeg.c
+++ b/drivers/media/platform/meson/vdec/codec_mjpeg.c
@@ -77,9 +77,6 @@ static void codec_mjpeg_init_scaler(struct amvdec_core *core)
 	amvdec_write_dos(core, PSCALE_BMEM_ADDR, 85);
 	amvdec_write_dos(core, PSCALE_BMEM_DAT, 0x10000);
 
-	amvdec_write_dos(core, DOS_SW_RESET0, (1 << 10));
-	amvdec_write_dos(core, DOS_SW_RESET0, 0);
-
 	amvdec_write_dos(core, PSCALE_RST, 0x7);
 	amvdec_write_dos(core, PSCALE_RST, 0);
 }
diff --git a/drivers/media/platform/meson/vdec/dos_regs.h b/drivers/media/platform/meson/vdec/dos_regs.h
index 1c0491a..74ad706 100644
--- a/drivers/media/platform/meson/vdec/dos_regs.h
+++ b/drivers/media/platform/meson/vdec/dos_regs.h
@@ -38,6 +38,7 @@
 #define ANC0_CANVAS_ADDR	0x2640
 #define MDEC_PIC_DC_THRESH	0x26e0
 
+/* Firmware interface registers */
 #define AV_SCRATCH_0		0x2700
 #define AV_SCRATCH_1		0x2704
 #define AV_SCRATCH_2		0x2708
@@ -66,6 +67,22 @@
 #define POWER_CTL_VLD		0x3020
 #define M4_CONTROL_REG		0x30a4
 
+/* Stream Buffer (stbuf) regs */
+#define VLD_MEM_VIFIFO_START_PTR	0x3100
+#define VLD_MEM_VIFIFO_CURR_PTR	0x3104
+#define VLD_MEM_VIFIFO_END_PTR	0x3108
+#define VLD_MEM_VIFIFO_CONTROL	0x3110
+	#define MEM_FIFO_CNT_BIT	16
+	#define MEM_FILL_ON_LEVEL	BIT(10)
+	#define MEM_CTRL_EMPTY_EN	BIT(2)
+	#define MEM_CTRL_FILL_EN	BIT(1)
+#define VLD_MEM_VIFIFO_WP	0x3114
+#define VLD_MEM_VIFIFO_RP	0x3118
+#define VLD_MEM_VIFIFO_LEVEL	0x311c
+#define VLD_MEM_VIFIFO_BUF_CNTL	0x3120
+	#define MEM_BUFCTRL_MANUAL	BIT(1)
+#define VLD_MEM_VIFIFO_WRAP_COUNT	0x3144
+
 #define DCAC_DMA_CTRL		0x3848
 
 #define DOS_SW_RESET0		0xfc00
diff --git a/drivers/media/platform/meson/vdec/esparser.c b/drivers/media/platform/meson/vdec/esparser.c
index da718ed..9fbfcb5 100644
--- a/drivers/media/platform/meson/vdec/esparser.c
+++ b/drivers/media/platform/meson/vdec/esparser.c
@@ -214,12 +214,12 @@ static int esparser_queue(struct amvdec_session *sess, struct vb2_v4l2_buffer *v
 	}
 
 	if (codec_ops->num_pending_bufs)
-		num_dst_bufs = codec_ops->num_pending_bufs(sess) + 1;
+		num_dst_bufs = codec_ops->num_pending_bufs(sess);
 
 	num_dst_bufs += v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
 
 	if (esparser_vififo_get_free_space(sess) < payload_size ||
-	    atomic_read(&sess->esparser_queued_bufs) >= (num_dst_bufs - 1))
+	    atomic_read(&sess->esparser_queued_bufs) >= (num_dst_bufs))
 		return -EAGAIN;
 
 	v4l2_m2m_src_buf_remove_by_buf(sess->m2m_ctx, vbuf);
@@ -266,6 +266,9 @@ void esparser_queue_all_src(struct work_struct *work)
 	v4l2_m2m_for_each_src_buf_safe(sess->m2m_ctx, buf, n) {
 		if (esparser_queue(sess, &buf->vb) < 0)
 			break;
+
+		/* Some codecs don't like having data queued in too fast */
+		usleep_range(1000, 2000);
 	}
 	mutex_unlock(&sess->lock);
 }
diff --git a/drivers/media/platform/meson/vdec/vdec.c b/drivers/media/platform/meson/vdec/vdec.c
index 1a048fe..f06b01e 100644
--- a/drivers/media/platform/meson/vdec/vdec.c
+++ b/drivers/media/platform/meson/vdec/vdec.c
@@ -62,8 +62,7 @@ static int vdec_recycle_thread(void *data)
 		mutex_lock(&sess->bufs_recycle_lock);
 
 		list_for_each_entry_safe(tmp, n, &sess->bufs_recycle, list) {
-			if (!codec_ops->can_recycle(core) ||
-			    sess->num_recycle < 2)
+			if (!codec_ops->can_recycle(core))
 				break;
 
 			codec_ops->recycle(core, tmp->vb->index);
@@ -71,7 +70,6 @@ static int vdec_recycle_thread(void *data)
 				tmp->vb->index);
 			list_del(&tmp->list);
 			kfree(tmp);
-			sess->num_recycle--;
 		}
 		mutex_unlock(&sess->bufs_recycle_lock);
 
@@ -127,7 +125,6 @@ static void vdec_queue_recycle(struct amvdec_session *sess, struct vb2_buffer *v
 
 	mutex_lock(&sess->bufs_recycle_lock);
 	list_add_tail(&new_buf->list, &sess->bufs_recycle);
-	sess->num_recycle++;
 	mutex_unlock(&sess->bufs_recycle_lock);
 }
 
@@ -239,7 +236,6 @@ static int vdec_start_streaming(struct vb2_queue *q, unsigned int count)
 		goto vififo_free;
 
 	sess->sequence_cap = 0;
-	sess->num_recycle = 0;
 	if (vdec_codec_needs_recycle(sess))
 		sess->recycle_thread = kthread_run(vdec_recycle_thread, sess,
 						   "vdec_recycle");
diff --git a/drivers/media/platform/meson/vdec/vdec.h b/drivers/media/platform/meson/vdec/vdec.h
index 246e704..ecce992 100644
--- a/drivers/media/platform/meson/vdec/vdec.h
+++ b/drivers/media/platform/meson/vdec/vdec.h
@@ -139,7 +139,6 @@ struct amvdec_session {
 	/* Buffers that need to be recycled by the HW */
 	struct list_head bufs_recycle;
 	struct mutex bufs_recycle_lock;
-	unsigned int num_recycle;
 	/* Thread for recycling buffers into the hardware */
 	struct task_struct *recycle_thread;
 	
diff --git a/drivers/media/platform/meson/vdec/vdec_1.c b/drivers/media/platform/meson/vdec/vdec_1.c
index f4f4e479..e97926e 100644
--- a/drivers/media/platform/meson/vdec/vdec_1.c
+++ b/drivers/media/platform/meson/vdec/vdec_1.c
@@ -14,23 +14,6 @@
 #define AO_RTI_GEN_PWR_ISO0	0xec
 	#define GEN_PWR_VDEC_1 (BIT(3) | BIT(2))
 
-/* Stream Buffer (stbuf) regs (DOS) */
-#define POWER_CTL_VLD 0x3020
-#define VLD_MEM_VIFIFO_START_PTR 0x3100
-#define VLD_MEM_VIFIFO_CURR_PTR 0x3104
-#define VLD_MEM_VIFIFO_END_PTR 0x3108
-#define VLD_MEM_VIFIFO_CONTROL 0x3110
-	#define MEM_FIFO_CNT_BIT	16
-	#define MEM_FILL_ON_LEVEL	BIT(10)
-	#define MEM_CTRL_EMPTY_EN	BIT(2)
-	#define MEM_CTRL_FILL_EN	BIT(1)
-#define VLD_MEM_VIFIFO_WP 0x3114
-#define VLD_MEM_VIFIFO_RP 0x3118
-#define VLD_MEM_VIFIFO_LEVEL 0x311c
-#define VLD_MEM_VIFIFO_BUF_CNTL 0x3120
-	#define MEM_BUFCTRL_MANUAL	BIT(1)
-#define VLD_MEM_VIFIFO_WRAP_COUNT 0x3144
-
 #define MC_SIZE			(4096 * 4)
 
 static int vdec_1_load_firmware(struct amvdec_session *sess, const char* fwname)
diff --git a/drivers/media/platform/meson/vdec/vdec_platform.c b/drivers/media/platform/meson/vdec/vdec_platform.c
index 0c7755f..52e9b35 100644
--- a/drivers/media/platform/meson/vdec/vdec_platform.c
+++ b/drivers/media/platform/meson/vdec/vdec_platform.c
@@ -17,7 +17,7 @@
 static const struct amvdec_format vdec_formats_gxbb[] = {
 	{
 		.pixfmt = V4L2_PIX_FMT_H264,
-		.min_buffers = 16,
+		.min_buffers = 21,
 		.max_buffers = 32,
 		.max_width = 1920,
 		.max_height = 1080,
@@ -101,7 +101,7 @@ static const struct amvdec_format vdec_formats_gxbb[] = {
 static const struct amvdec_format vdec_formats_gxl[] = {
 	{
 		.pixfmt = V4L2_PIX_FMT_H264,
-		.min_buffers = 16,
+		.min_buffers = 21,
 		.max_buffers = 32,
 		.max_width = 3840,
 		.max_height = 2160,
@@ -185,7 +185,7 @@ static const struct amvdec_format vdec_formats_gxl[] = {
 static const struct amvdec_format vdec_formats_gxm[] = {
 	{
 		.pixfmt = V4L2_PIX_FMT_H264,
-		.min_buffers = 16,
+		.min_buffers = 21,
 		.max_buffers = 32,
 		.max_width = 3840,
 		.max_height = 2160,
-- 
2.7.4

